{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introdu\u00e7\u00e3o ao PyQGIS Descri\u00e7\u00e3o Esta Wiki tem a finalidade de apresentar um material did\u00e1tico b\u00e1sico sobre PyQGIS para o desenvolvimento de ferramentas que possam auxiliar na produ\u00e7\u00e3o de geoinforma\u00e7\u00e3o. Se\u00e7\u00f5es 1) Introdu\u00e7\u00e3o ao Python 2) Links \u00dateis 3) Console Python 4) Processing 5) Plugin 6) Colaboradores","title":"Introdu\u00e7\u00e3o ao PyQGIS"},{"location":"#introducao-ao-pyqgis","text":"","title":"Introdu\u00e7\u00e3o ao PyQGIS"},{"location":"#descricao","text":"Esta Wiki tem a finalidade de apresentar um material did\u00e1tico b\u00e1sico sobre PyQGIS para o desenvolvimento de ferramentas que possam auxiliar na produ\u00e7\u00e3o de geoinforma\u00e7\u00e3o.","title":"Descri\u00e7\u00e3o"},{"location":"#secoes","text":"1) Introdu\u00e7\u00e3o ao Python 2) Links \u00dateis 3) Console Python 4) Processing 5) Plugin 6) Colaboradores","title":"Se\u00e7\u00f5es"},{"location":"1%29-Introdu%C3%A7%C3%A3o-ao-Python/","text":"A Estrutura do Python Vari\u00e1veis Vari\u00e1veis s\u00e3o espa\u00e7os de mem\u00f3ria utilizados para armazenar e manipular dados. Diferentemente de outras linguagens de programa\u00e7\u00e3o, n\u00e3o \u00e9 necess\u00e1rio declarar o tipo das vari\u00e1veis a serem usadas no in\u00edcio do c\u00f3digo. Alguns dos tipos de vari\u00e1veis mais utilizados no Python s\u00e3o: * int: armazena n\u00fameros inteiros. * float: armazena n\u00fameros decimais. * string: armazena caracteres de texto N\u00fameros Os tipos de n\u00fameros utilizados no Python s\u00e3o: * int: n\u00fameros inteiros * float: n\u00fameros decimais * long: n\u00fameros decimais longos * complex: n\u00fameros complexos Para manipular os n\u00fameros no Python, o usu\u00e1rio disp\u00f5e de diversos operadores aritm\u00e9ticos, l\u00f3gicos e de compara\u00e7\u00e3o. Operadores Aritm\u00e9ticos: S\u00edmbolo Descri\u00e7\u00e3o Exemplo + Soma 5+5=10 - Subtra\u00e7\u00e3o 7-2=5 * Multiplica\u00e7\u00e3o 3*4=12 / Divis\u00e3o 9/3=3 % Resto da divis\u00e3o 10%3=1 ** Pot\u00eancia 3**3=27 Operadores de Compara\u00e7\u00e3o: Operador Descri\u00e7\u00e3o Exemplo < Menor que a<10 <= Menor ou igual b<=5 > Maior que c>2 >= Maior ou igual d>=8 == Igual e==5 != Diferente f!=12 Operadores L\u00f3gicos: Operador Descri\u00e7\u00e3o Exemplo not N\u00e3o not a and E (a<=10) and (c=5) or Ou (a<=10) or (c=5) Strings As strings, como visto anteriormente, s\u00e3o um conjunto de caracteres. Normalmente, s\u00e3o utilizadas quando as vari\u00e1veis utilizadas s\u00e3o um texto (palavra, frase, \u2026). Diferentemente dos n\u00fameros, as strings precisam ser introduzidas por meio de aspas simples ou duplas para que sejam reconhecidas pelo Python. No Python, encontramos diversas fun\u00e7\u00f5es para a manipula\u00e7\u00e3o de strings, uma vez que s\u00e3o vari\u00e1veis que n\u00e3o aceitam operadores como os n\u00fameros. Assim, apresentamos abaixo algumas fun\u00e7\u00f5es utilizadas quando trabalhamos com strings: M\u00e9todo Descri\u00e7\u00e3o Exemplo len() Retorna o tamanho da string. string = \u201cpython\u201d len(string) 6 capitalize() Retorna a string com a primeira letra mai\u00fascula. string = \u201cpython\u201d string.capitalize() \u201cPython\u201d count() Informa quantas vezes um caractere aparece na string. string = \u201cpython forever\u201d string.count(\u201co\u201d) 2 startswith() Verifica se a string inicia com determinada sequ\u00eancia. string = \u201cpython\u201d string.startswith(\u201cpyt\u201d) True replace(x1,x2) Substitui na string o trecho x1 pelo x2. string = \u201cpython\u201d string.replace(\u201cthon\u201d,\u201cQGIS\u201d) \u201cpyQGIS\u201d find() Retorna o \u00edndice da primeira ocorr\u00eancia de um determinado caractere na string. string = \u201cpython\u201d string.find(\u201ch\u201d) 3 Al\u00e9m disso, \u00e9 poss\u00edvel manipular strings apenas com operadores presentes no Python, sem a necessidade de utilizar uma fun\u00e7\u00e3o. Abaixo, encontram-se exemplos de como utiliz\u00e1-los: * Concatena\u00e7\u00e3o: a = \"Py\" b = \"thon\" ---------- a+b = \"Python\" Fatiamento: a = \"Python\" ------------ a[1:4] -> \"yth\" a[:3] -> \"Pyt\" a[2:] -> \"thon\" Listas Listas s\u00e3o conjuntos sequenciais de valores, sendo cada um deles identificado por um \u00edndice. Os \u00edndices s\u00e3o sequenciais e come\u00e7am no \u201c0\u201d. Para se declarar uma lista, \u00e9 necess\u00e1ria a seguinte forma: lista = [\"python\", 1234, [1,2,3,4]] ----------------------------------- lista[0] -> \"python\" lista[1] -> 1234 lista[2] -> [1,2,3,4] len(lista) = 3 Para alterar algum elemento da lista, basta fazer uma atribui\u00e7\u00e3o de valor atrav\u00e9s do \u00edndice. lista = [\"python\", 1234, [1,2,3,4]] ----------------------------------- lista[0] = \"QGIS\" lista -> [\"QGIS\", 1234, [1,2,3,4]] Assim como as strings, as listas tamb\u00e9m possuem fun\u00e7\u00f5es espec\u00edficas que auxiliam o usu\u00e1rio em sua manipula\u00e7\u00e3o. Algumas muito utilizadas est\u00e3o apresentadas na tabela abaixo: M\u00e9todo Descri\u00e7\u00e3o Exemplo len() Retorna o tamanho da lista. lista = [1, 2, 3, 4] len(lista) 4 min()/max() Retorna o menor/maior valor da lista. lista = [1, 2, 3, 4] min(lista) 1 sum() Retorna a soma dos elementos da lista. lista = [1, 2, 3, 4] sum(lista) 10 append() Adiciona um novo valor ao final de outra lista. lista = [1, 2, 3, 4] lista.append(5) lista = [1, 2, 3, 4, 5] del() Remove um elemento da lista. lista = [1, 2, 3, 4] del lista[0] lista = [2, 3, 4] sort() Ordena os elementos da lista em ordem crescente. lista = [4, 3, 2, 1] lista.sort() lista = [1, 2, 3, 4] reverse() Inverte os elementos da lista. lista = [1, 2, 3, 4] lista.reverse() lista = [4, 3, 2, 1] Al\u00e9m das fun\u00e7\u00f5es, o Python possui operadores que auxiliam na manipula\u00e7\u00e3o de listas: * Concatena\u00e7\u00e3o : a = [1, 2, 3] b = [4, 5, 6] ------------- a + b -> [1, 2, 3, 4, 5, 6] Repeti\u00e7\u00e3o : a = [1, 2, 3] ------------- a*3 -> [1, 2, 3, 1, 2, 3, 1, 2, 3] Fatiamento : lista = [\"python\", 123, [1, 2, 3]] ---------------------------------- lista[1:2] -> [123] lista[:3] -> [\"python\", 123, [1, 2, 3]] lista[2:] -> [[1, 2, 3]] Tuplas As tuplas, assim como as listas, s\u00e3o conjuntos sequenciais de valores, sendo cada valor identificado por um \u00edndice. A principal diferen\u00e7a entre elas \u00e9 que as tuplas s\u00e3o imut\u00e1veis, ou seja, seus elementos n\u00e3o podem ser alterados. Al\u00e9m disso, visualmente, as tuplas s\u00e3o apresentadas com par\u00eanteses, diferentemente dos colchetes de uma lista. tupla = (1, 2, 3, 4) -------------------- type(tupla) -> tuple Uma importante aplica\u00e7\u00e3o das tuplas \u00e9 a possibilidade de \u201cdesempacotar\u201d seus elementos, permitindo atribu\u00ed-los a diversas vari\u00e1veis. tupla = (1, 2, 3, 4) a, b, c, d = tupla -------------------- a -> 1 b -> 2 c -> 3 d -> 4 Dicion\u00e1rios Dicion\u00e1rio \u00e9 um conjunto de valores, sendo cada um desses valores associados a uma chave de acesso. Eles s\u00e3o declarados da seguinte forma: dic = {\"arroz\": 20.50, \"gasolina\": 6.70, \"g\u00e1s\": 97} \u00c9 poss\u00edvel, tamb\u00e9m, acrescentar ou modificar valores no dicion\u00e1rio: dic = {\"arroz\": 20.50, \"gasolina\": 6.70, \"g\u00e1s\": 97} dic[\"luz\"] = 14.10 dic[\"gasolina\"] = 7.10 --------------------------------------------------- dic -> {\"arroz\": 20.50, \"gasolina\": 7.10, \"g\u00e1s\": 97, \"luz\": 14.10} Os dicion\u00e1rios tamb\u00e9m possuem comandos especiais para sua manipula\u00e7\u00e3o: M\u00e9todo Descri\u00e7\u00e3o Exemplo del Exclui item informando a chave. del dic[\u201carroz\u201d] dic = {\u2018gasolina\u2019: 7.1, \u2018g\u00e1s\u2019: 97, \u2018luz\u2019: 14.1} in Verifica se uma chave existe no dicion\u00e1rio. \u201cbebida\u201d in dic False keys() Obt\u00e9m as chaves de um dicion\u00e1rio. dic.keys() dict_keys([\u2018arroz\u2019, \u2018gasolina\u2019, \u2018g\u00e1s\u2019, \u2018luz\u2019]) values() Obt\u00e9m os valores de um dicion\u00e1rio. dic.values() dict_values([20.50, 6.40, 97, 14.1]) Bibliotecas As bibliotecas armazenam fun\u00e7\u00f5es predefinidas que podem ser utilizadas em qualquer momento do programa. No Python, muitas bibliotecas s\u00e3o instaladas por padr\u00e3o junto com o programa. Normalmente, as bibliotecas s\u00e3o chamadas no in\u00edcio do c\u00f3digo e, para fazer isso, \u00e9 necess\u00e1rio usar o comando \u201cimport\u201d da seguinte forma: import math print(math.factorial(6)) ------------------------ 720 from math import factorial print(factorial(6)) -------------------------- 720 Abaixo, listamos algumas bibliotecas bastante utilizadas no Python: M\u00e9todo Descri\u00e7\u00e3o math Fun\u00e7\u00f5es matem\u00e1ticas. numpy Fun\u00e7\u00f5es matem\u00e1ticas avan\u00e7adas. time Fun\u00e7\u00f5es de tempo. tkinter Fun\u00e7\u00f5es de interface gr\u00e1fica. pillow Fun\u00e7\u00f5es para manipula\u00e7\u00e3o de imagens. Estruturas de Decis\u00e3o As estruturas condicionais, tamb\u00e9m chamadas de estruturas de decis\u00e3o, permitem que o programador altere o fluxo de execu\u00e7\u00e3o de um programa de acordo com o valor (True/False) de um teste l\u00f3gico. No Python, temos tr\u00eas estruturas para isso: \u201cif\u201d, \u201cif...else\u201d e \u201cif...elif...else\u201d. * if: O \u201cif\u201d \u00e9 utilizado quando precisamos decidir se uma parte do c\u00f3digo deve ou n\u00e3o ser executada de acordo com uma condi\u00e7\u00e3o proposta. a = 121 if a%11 == 0: print(\"a \u00e9 m\u00faltiplo de 11\") if...else: O \u201cif...else\u201d \u00e9 utilizado quando queremos que uma parte do c\u00f3digo seja executada caso, na primeira condicional, tenha sido negada. a = 121 if a%11 == 0: print(\"a \u00e9 m\u00faltiplo de 11\") else: print(\"a n\u00e3o \u00e9 m\u00faltiplo de 11\") if...elif...else: O \u201cif...elif...else\u201d \u00e9 utilizado quando existem diversas condi\u00e7\u00f5es no c\u00f3digo. gasolina = 6.40 if gasolina <= 4: print(\"A gasolina est\u00e1 barata!\") elif gasolina > 4 and gasolina <= 6: print(\"O pre\u00e7o est\u00e1 razo\u00e1vel.\") else: print(\"A gasolina est\u00e1 muito cara!\") Estruturas de Repeti\u00e7\u00e3o No Python, a recorr\u00eancia, tamb\u00e9m chamada de estrutura de repeti\u00e7\u00e3o, \u00e9 utilizada para executar uma mesma sequ\u00eancia de comandos por diversas vezes, sendo direcionada por uma condi\u00e7\u00e3o proposta no c\u00f3digo. * While: No \u201cwhile\u201d, o trecho do c\u00f3digo da repeti\u00e7\u00e3o est\u00e1 associado a uma condi\u00e7\u00e3o, sendo executado enquanto a condi\u00e7\u00e3o tiver o valor \u201cverdadeiro\u201d e finalizado, se \u201cfalso\u201d. senha = \"python\" leitor = \"\" while (leitor != senha): leitor = input(\"Digite a senha: \") if leitor == senha: print(\"Acesso liberado.\") else: print(\"Senha incorreta. Tente novamente.\") For: Assim como o \u201cwhile\u201d, o \u201cfor\u201d possibilita estabelecer uma estrutura de repeti\u00e7\u00e3o. Entretanto, o \u201cfor\u201d possui grande aplicabilidade quando queremos trabalhar com sequ\u00eancias num\u00e9ricas, geradas com o comando \u201crange\u201d, ou mesmo associado a uma lista, sendo o trecho do c\u00f3digo executado para cada valor da sequ\u00eancia num\u00e9rica gerada ou da lista utilizada. soma = 0\" for i in range(10): soma = soma = i print(soma) ------------------- notas = [3.10, 4.20, 5.30, 6.40, 7.50, 8.60] soma = 0 for i in notas: soma = soma + i print(soma) Fun\u00e7\u00f5es As fun\u00e7\u00f5es s\u00e3o trechos de c\u00f3digo, com nome e comandos espec\u00edficos, que podem ser utilizados in\u00fameras vezes e em qualquer lugar do programa. No c\u00f3digo abaixo, est\u00e1 definida a fun\u00e7\u00e3o \u201csoma\u201d que tem como par\u00e2metro de entrada a lista \u201cnotas\u201d. def soma(notas) s = 0 for i in notas: s = s + i print(s) ------------------ notas = [3.10, 4.20, 5.30, 6.40, 7.50, 8.60] soma(notas) -> 35.10 Ap\u00f3s definir a fun\u00e7\u00e3o, podemos definir a lista que queremos trabalhar e, em seguida, devemos chamar a fun\u00e7\u00e3o conforme foi feito e colocando a lista \u201cnotas\u201d como par\u00e2metro de entrada. Os par\u00e2metros s\u00e3o vari\u00e1veis que podem ser inclu\u00eddas dentro dos par\u00eanteses das fun\u00e7\u00f5es, sendo elas necess\u00e1rias para dar prosseguimento no c\u00f3digo. def maior(x,y) if x > y: print(x, \"\u00e9 maior que\", y) elif x == y: print(\"Os n\u00fameros s\u00e3o iguais\") else: print(y, \"\u00e9 maior que\", x) Um t\u00f3pico importante sobre as fun\u00e7\u00f5es \u00e9 que toda vari\u00e1vel utilizada dentro de uma fun\u00e7\u00e3o \u00e9 uma vari\u00e1vel local, ou seja, ela n\u00e3o ser\u00e1 acess\u00edvel fora de sua fun\u00e7\u00e3o m\u00e3e. Mesmo se houver outra vari\u00e1vel fora da fun\u00e7\u00e3o com o mesmo nome, elas ser\u00e3o completamente diferentes entre si. Para uma vari\u00e1vel ser compartilhada entre diversas fun\u00e7\u00f5es e o programa principal, ela deve ser definida como uma \u201cvari\u00e1vel global\u201d. Para isso, utiliza-se o comando \u201cglobal\u201d para declarar globalmente a vari\u00e1vel. def soma(x,y) global total total = x + y print(\"Soma = \", total) def soma_2(x) global total total = total + x print(total) -------------------------- soma(3,5) -> Soma = 8 soma_2(11) -> 19 No exemplo acima, a fun\u00e7\u00e3o \u201csoma_2\u201d toma como par\u00e2metro a vari\u00e1vel global \u201ctotal\u201d que tamb\u00e9m foi utilizada na fun\u00e7\u00e3o \u201csoma\u201d. Assim, a fun\u00e7\u00e3o \u201csoma_2\u201d ir\u00e1 utilizar o valor da vari\u00e1vel \u201ctotal\u201d de acordo com o que foi realizado na fun\u00e7\u00e3o \u201csoma\u201d. Um comando que tamb\u00e9m pode ser utilizado em fun\u00e7\u00f5es \u00e9 o \u201creturn\u201d. Esse comando tem o objetivo de retornar um valor ao finalizar o uso da fun\u00e7\u00e3o. Quando falamos em retornar um valor, queremos dizer que o valor retornado pela fun\u00e7\u00e3o estar\u00e1 guardado na mem\u00f3ria, mas n\u00e3o estar\u00e1 vis\u00edvel. Para torn\u00e1-lo vis\u00edvel, \u00e9 necess\u00e1rio fazer o uso de alguma fun\u00e7\u00e3o para exibi-lo. No exemplo abaixo, foi utilizada o \u201cprint\u201d para que o usu\u00e1rio possa ver o valor retornado. def soma(x,y) global total total = x + y return total ---------------- print(soma(3,5)) -> 8 List Comprehension List Comprehension \u00e9 uma forma concisa de criar e manipular listas. Abaixo, mostramos um exemplo de cria\u00e7\u00e3o de lista das duas poss\u00edveis formas: for item in range(10): lista.append(item**2) ------------------------ lista = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] lista = [item**2 for item in range(10)] --------------------------------------- lista = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] List Comprehension com if Podemos utilizar, tamb\u00e9m, express\u00f5es condicionais para criar listas ou modificar listas existentes da seguinte forma: (Exemplo: obter os n\u00fameros pares at\u00e9 19) resultado = [numero for numero in range(20) if numero%2 == 0] ------------------------------------------------------------- resultado = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] Caso o c\u00f3digo utilizado tenha v\u00e1rios \"if\", a sintaxe ser\u00e1 feita da seguinte forma: (Exemplo: obter os m\u00faltiplos de 5 e 6 at\u00e9 99) resultado = [numero for numero in range(100) if numero%5 == 0 if numero%6 == 0] ------------------------------------------------------------------------------- resultado = [0, 30, 60, 90] List Comprehension com if...else Tamb\u00e9m \u00e9 poss\u00edvel utilizar List Comprehension com if..else utilizando a seguinte sintaxe: (Exemplo: criar lista que contenha \"1\" quando determinado n\u00famero for m\u00faltiplo de 5 e \"0\" caso contr\u00e1rio) resultado = ['1' if numero % 5 == 0 else '0' for numero in range(16)] --------------------------------------------------------------------- resultado = ['1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '1'] M\u00faltiplas List Comprehension Existe a possibilidade de incluirmos List Comprehension dentro de outra List Comprehension. Essa situa\u00e7\u00e3o ocorre, normalmente, quando trabalhamos com matrizes. Abaixo, exemplificamos a transposi\u00e7\u00e3o de uma matriz utilizando List Comprehension: matriz = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] transposta = [[linha[i] for linha in matriz] for i in range(4)] --------------------------------------------------------------- transposta = [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]","title":"1) Introdu\u00e7\u00e3o ao Python"},{"location":"1%29-Introdu%C3%A7%C3%A3o-ao-Python/#a-estrutura-do-python","text":"","title":"A Estrutura do Python"},{"location":"1%29-Introdu%C3%A7%C3%A3o-ao-Python/#variaveis","text":"Vari\u00e1veis s\u00e3o espa\u00e7os de mem\u00f3ria utilizados para armazenar e manipular dados. Diferentemente de outras linguagens de programa\u00e7\u00e3o, n\u00e3o \u00e9 necess\u00e1rio declarar o tipo das vari\u00e1veis a serem usadas no in\u00edcio do c\u00f3digo. Alguns dos tipos de vari\u00e1veis mais utilizados no Python s\u00e3o: * int: armazena n\u00fameros inteiros. * float: armazena n\u00fameros decimais. * string: armazena caracteres de texto","title":"Vari\u00e1veis"},{"location":"1%29-Introdu%C3%A7%C3%A3o-ao-Python/#numeros","text":"Os tipos de n\u00fameros utilizados no Python s\u00e3o: * int: n\u00fameros inteiros * float: n\u00fameros decimais * long: n\u00fameros decimais longos * complex: n\u00fameros complexos Para manipular os n\u00fameros no Python, o usu\u00e1rio disp\u00f5e de diversos operadores aritm\u00e9ticos, l\u00f3gicos e de compara\u00e7\u00e3o. Operadores Aritm\u00e9ticos: S\u00edmbolo Descri\u00e7\u00e3o Exemplo + Soma 5+5=10 - Subtra\u00e7\u00e3o 7-2=5 * Multiplica\u00e7\u00e3o 3*4=12 / Divis\u00e3o 9/3=3 % Resto da divis\u00e3o 10%3=1 ** Pot\u00eancia 3**3=27 Operadores de Compara\u00e7\u00e3o: Operador Descri\u00e7\u00e3o Exemplo < Menor que a<10 <= Menor ou igual b<=5 > Maior que c>2 >= Maior ou igual d>=8 == Igual e==5 != Diferente f!=12 Operadores L\u00f3gicos: Operador Descri\u00e7\u00e3o Exemplo not N\u00e3o not a and E (a<=10) and (c=5) or Ou (a<=10) or (c=5)","title":"N\u00fameros"},{"location":"1%29-Introdu%C3%A7%C3%A3o-ao-Python/#strings","text":"As strings, como visto anteriormente, s\u00e3o um conjunto de caracteres. Normalmente, s\u00e3o utilizadas quando as vari\u00e1veis utilizadas s\u00e3o um texto (palavra, frase, \u2026). Diferentemente dos n\u00fameros, as strings precisam ser introduzidas por meio de aspas simples ou duplas para que sejam reconhecidas pelo Python. No Python, encontramos diversas fun\u00e7\u00f5es para a manipula\u00e7\u00e3o de strings, uma vez que s\u00e3o vari\u00e1veis que n\u00e3o aceitam operadores como os n\u00fameros. Assim, apresentamos abaixo algumas fun\u00e7\u00f5es utilizadas quando trabalhamos com strings: M\u00e9todo Descri\u00e7\u00e3o Exemplo len() Retorna o tamanho da string. string = \u201cpython\u201d len(string) 6 capitalize() Retorna a string com a primeira letra mai\u00fascula. string = \u201cpython\u201d string.capitalize() \u201cPython\u201d count() Informa quantas vezes um caractere aparece na string. string = \u201cpython forever\u201d string.count(\u201co\u201d) 2 startswith() Verifica se a string inicia com determinada sequ\u00eancia. string = \u201cpython\u201d string.startswith(\u201cpyt\u201d) True replace(x1,x2) Substitui na string o trecho x1 pelo x2. string = \u201cpython\u201d string.replace(\u201cthon\u201d,\u201cQGIS\u201d) \u201cpyQGIS\u201d find() Retorna o \u00edndice da primeira ocorr\u00eancia de um determinado caractere na string. string = \u201cpython\u201d string.find(\u201ch\u201d) 3 Al\u00e9m disso, \u00e9 poss\u00edvel manipular strings apenas com operadores presentes no Python, sem a necessidade de utilizar uma fun\u00e7\u00e3o. Abaixo, encontram-se exemplos de como utiliz\u00e1-los: * Concatena\u00e7\u00e3o: a = \"Py\" b = \"thon\" ---------- a+b = \"Python\" Fatiamento: a = \"Python\" ------------ a[1:4] -> \"yth\" a[:3] -> \"Pyt\" a[2:] -> \"thon\"","title":"Strings"},{"location":"1%29-Introdu%C3%A7%C3%A3o-ao-Python/#listas","text":"Listas s\u00e3o conjuntos sequenciais de valores, sendo cada um deles identificado por um \u00edndice. Os \u00edndices s\u00e3o sequenciais e come\u00e7am no \u201c0\u201d. Para se declarar uma lista, \u00e9 necess\u00e1ria a seguinte forma: lista = [\"python\", 1234, [1,2,3,4]] ----------------------------------- lista[0] -> \"python\" lista[1] -> 1234 lista[2] -> [1,2,3,4] len(lista) = 3 Para alterar algum elemento da lista, basta fazer uma atribui\u00e7\u00e3o de valor atrav\u00e9s do \u00edndice. lista = [\"python\", 1234, [1,2,3,4]] ----------------------------------- lista[0] = \"QGIS\" lista -> [\"QGIS\", 1234, [1,2,3,4]] Assim como as strings, as listas tamb\u00e9m possuem fun\u00e7\u00f5es espec\u00edficas que auxiliam o usu\u00e1rio em sua manipula\u00e7\u00e3o. Algumas muito utilizadas est\u00e3o apresentadas na tabela abaixo: M\u00e9todo Descri\u00e7\u00e3o Exemplo len() Retorna o tamanho da lista. lista = [1, 2, 3, 4] len(lista) 4 min()/max() Retorna o menor/maior valor da lista. lista = [1, 2, 3, 4] min(lista) 1 sum() Retorna a soma dos elementos da lista. lista = [1, 2, 3, 4] sum(lista) 10 append() Adiciona um novo valor ao final de outra lista. lista = [1, 2, 3, 4] lista.append(5) lista = [1, 2, 3, 4, 5] del() Remove um elemento da lista. lista = [1, 2, 3, 4] del lista[0] lista = [2, 3, 4] sort() Ordena os elementos da lista em ordem crescente. lista = [4, 3, 2, 1] lista.sort() lista = [1, 2, 3, 4] reverse() Inverte os elementos da lista. lista = [1, 2, 3, 4] lista.reverse() lista = [4, 3, 2, 1] Al\u00e9m das fun\u00e7\u00f5es, o Python possui operadores que auxiliam na manipula\u00e7\u00e3o de listas: * Concatena\u00e7\u00e3o : a = [1, 2, 3] b = [4, 5, 6] ------------- a + b -> [1, 2, 3, 4, 5, 6] Repeti\u00e7\u00e3o : a = [1, 2, 3] ------------- a*3 -> [1, 2, 3, 1, 2, 3, 1, 2, 3] Fatiamento : lista = [\"python\", 123, [1, 2, 3]] ---------------------------------- lista[1:2] -> [123] lista[:3] -> [\"python\", 123, [1, 2, 3]] lista[2:] -> [[1, 2, 3]]","title":"Listas"},{"location":"1%29-Introdu%C3%A7%C3%A3o-ao-Python/#tuplas","text":"As tuplas, assim como as listas, s\u00e3o conjuntos sequenciais de valores, sendo cada valor identificado por um \u00edndice. A principal diferen\u00e7a entre elas \u00e9 que as tuplas s\u00e3o imut\u00e1veis, ou seja, seus elementos n\u00e3o podem ser alterados. Al\u00e9m disso, visualmente, as tuplas s\u00e3o apresentadas com par\u00eanteses, diferentemente dos colchetes de uma lista. tupla = (1, 2, 3, 4) -------------------- type(tupla) -> tuple Uma importante aplica\u00e7\u00e3o das tuplas \u00e9 a possibilidade de \u201cdesempacotar\u201d seus elementos, permitindo atribu\u00ed-los a diversas vari\u00e1veis. tupla = (1, 2, 3, 4) a, b, c, d = tupla -------------------- a -> 1 b -> 2 c -> 3 d -> 4","title":"Tuplas"},{"location":"1%29-Introdu%C3%A7%C3%A3o-ao-Python/#dicionarios","text":"Dicion\u00e1rio \u00e9 um conjunto de valores, sendo cada um desses valores associados a uma chave de acesso. Eles s\u00e3o declarados da seguinte forma: dic = {\"arroz\": 20.50, \"gasolina\": 6.70, \"g\u00e1s\": 97} \u00c9 poss\u00edvel, tamb\u00e9m, acrescentar ou modificar valores no dicion\u00e1rio: dic = {\"arroz\": 20.50, \"gasolina\": 6.70, \"g\u00e1s\": 97} dic[\"luz\"] = 14.10 dic[\"gasolina\"] = 7.10 --------------------------------------------------- dic -> {\"arroz\": 20.50, \"gasolina\": 7.10, \"g\u00e1s\": 97, \"luz\": 14.10} Os dicion\u00e1rios tamb\u00e9m possuem comandos especiais para sua manipula\u00e7\u00e3o: M\u00e9todo Descri\u00e7\u00e3o Exemplo del Exclui item informando a chave. del dic[\u201carroz\u201d] dic = {\u2018gasolina\u2019: 7.1, \u2018g\u00e1s\u2019: 97, \u2018luz\u2019: 14.1} in Verifica se uma chave existe no dicion\u00e1rio. \u201cbebida\u201d in dic False keys() Obt\u00e9m as chaves de um dicion\u00e1rio. dic.keys() dict_keys([\u2018arroz\u2019, \u2018gasolina\u2019, \u2018g\u00e1s\u2019, \u2018luz\u2019]) values() Obt\u00e9m os valores de um dicion\u00e1rio. dic.values() dict_values([20.50, 6.40, 97, 14.1])","title":"Dicion\u00e1rios"},{"location":"1%29-Introdu%C3%A7%C3%A3o-ao-Python/#bibliotecas","text":"As bibliotecas armazenam fun\u00e7\u00f5es predefinidas que podem ser utilizadas em qualquer momento do programa. No Python, muitas bibliotecas s\u00e3o instaladas por padr\u00e3o junto com o programa. Normalmente, as bibliotecas s\u00e3o chamadas no in\u00edcio do c\u00f3digo e, para fazer isso, \u00e9 necess\u00e1rio usar o comando \u201cimport\u201d da seguinte forma: import math print(math.factorial(6)) ------------------------ 720 from math import factorial print(factorial(6)) -------------------------- 720 Abaixo, listamos algumas bibliotecas bastante utilizadas no Python: M\u00e9todo Descri\u00e7\u00e3o math Fun\u00e7\u00f5es matem\u00e1ticas. numpy Fun\u00e7\u00f5es matem\u00e1ticas avan\u00e7adas. time Fun\u00e7\u00f5es de tempo. tkinter Fun\u00e7\u00f5es de interface gr\u00e1fica. pillow Fun\u00e7\u00f5es para manipula\u00e7\u00e3o de imagens.","title":"Bibliotecas"},{"location":"1%29-Introdu%C3%A7%C3%A3o-ao-Python/#estruturas-de-decisao","text":"As estruturas condicionais, tamb\u00e9m chamadas de estruturas de decis\u00e3o, permitem que o programador altere o fluxo de execu\u00e7\u00e3o de um programa de acordo com o valor (True/False) de um teste l\u00f3gico. No Python, temos tr\u00eas estruturas para isso: \u201cif\u201d, \u201cif...else\u201d e \u201cif...elif...else\u201d. * if: O \u201cif\u201d \u00e9 utilizado quando precisamos decidir se uma parte do c\u00f3digo deve ou n\u00e3o ser executada de acordo com uma condi\u00e7\u00e3o proposta. a = 121 if a%11 == 0: print(\"a \u00e9 m\u00faltiplo de 11\") if...else: O \u201cif...else\u201d \u00e9 utilizado quando queremos que uma parte do c\u00f3digo seja executada caso, na primeira condicional, tenha sido negada. a = 121 if a%11 == 0: print(\"a \u00e9 m\u00faltiplo de 11\") else: print(\"a n\u00e3o \u00e9 m\u00faltiplo de 11\") if...elif...else: O \u201cif...elif...else\u201d \u00e9 utilizado quando existem diversas condi\u00e7\u00f5es no c\u00f3digo. gasolina = 6.40 if gasolina <= 4: print(\"A gasolina est\u00e1 barata!\") elif gasolina > 4 and gasolina <= 6: print(\"O pre\u00e7o est\u00e1 razo\u00e1vel.\") else: print(\"A gasolina est\u00e1 muito cara!\")","title":"Estruturas de Decis\u00e3o"},{"location":"1%29-Introdu%C3%A7%C3%A3o-ao-Python/#estruturas-de-repeticao","text":"No Python, a recorr\u00eancia, tamb\u00e9m chamada de estrutura de repeti\u00e7\u00e3o, \u00e9 utilizada para executar uma mesma sequ\u00eancia de comandos por diversas vezes, sendo direcionada por uma condi\u00e7\u00e3o proposta no c\u00f3digo. * While: No \u201cwhile\u201d, o trecho do c\u00f3digo da repeti\u00e7\u00e3o est\u00e1 associado a uma condi\u00e7\u00e3o, sendo executado enquanto a condi\u00e7\u00e3o tiver o valor \u201cverdadeiro\u201d e finalizado, se \u201cfalso\u201d. senha = \"python\" leitor = \"\" while (leitor != senha): leitor = input(\"Digite a senha: \") if leitor == senha: print(\"Acesso liberado.\") else: print(\"Senha incorreta. Tente novamente.\") For: Assim como o \u201cwhile\u201d, o \u201cfor\u201d possibilita estabelecer uma estrutura de repeti\u00e7\u00e3o. Entretanto, o \u201cfor\u201d possui grande aplicabilidade quando queremos trabalhar com sequ\u00eancias num\u00e9ricas, geradas com o comando \u201crange\u201d, ou mesmo associado a uma lista, sendo o trecho do c\u00f3digo executado para cada valor da sequ\u00eancia num\u00e9rica gerada ou da lista utilizada. soma = 0\" for i in range(10): soma = soma = i print(soma) ------------------- notas = [3.10, 4.20, 5.30, 6.40, 7.50, 8.60] soma = 0 for i in notas: soma = soma + i print(soma)","title":"Estruturas de Repeti\u00e7\u00e3o"},{"location":"1%29-Introdu%C3%A7%C3%A3o-ao-Python/#funcoes","text":"As fun\u00e7\u00f5es s\u00e3o trechos de c\u00f3digo, com nome e comandos espec\u00edficos, que podem ser utilizados in\u00fameras vezes e em qualquer lugar do programa. No c\u00f3digo abaixo, est\u00e1 definida a fun\u00e7\u00e3o \u201csoma\u201d que tem como par\u00e2metro de entrada a lista \u201cnotas\u201d. def soma(notas) s = 0 for i in notas: s = s + i print(s) ------------------ notas = [3.10, 4.20, 5.30, 6.40, 7.50, 8.60] soma(notas) -> 35.10 Ap\u00f3s definir a fun\u00e7\u00e3o, podemos definir a lista que queremos trabalhar e, em seguida, devemos chamar a fun\u00e7\u00e3o conforme foi feito e colocando a lista \u201cnotas\u201d como par\u00e2metro de entrada. Os par\u00e2metros s\u00e3o vari\u00e1veis que podem ser inclu\u00eddas dentro dos par\u00eanteses das fun\u00e7\u00f5es, sendo elas necess\u00e1rias para dar prosseguimento no c\u00f3digo. def maior(x,y) if x > y: print(x, \"\u00e9 maior que\", y) elif x == y: print(\"Os n\u00fameros s\u00e3o iguais\") else: print(y, \"\u00e9 maior que\", x) Um t\u00f3pico importante sobre as fun\u00e7\u00f5es \u00e9 que toda vari\u00e1vel utilizada dentro de uma fun\u00e7\u00e3o \u00e9 uma vari\u00e1vel local, ou seja, ela n\u00e3o ser\u00e1 acess\u00edvel fora de sua fun\u00e7\u00e3o m\u00e3e. Mesmo se houver outra vari\u00e1vel fora da fun\u00e7\u00e3o com o mesmo nome, elas ser\u00e3o completamente diferentes entre si. Para uma vari\u00e1vel ser compartilhada entre diversas fun\u00e7\u00f5es e o programa principal, ela deve ser definida como uma \u201cvari\u00e1vel global\u201d. Para isso, utiliza-se o comando \u201cglobal\u201d para declarar globalmente a vari\u00e1vel. def soma(x,y) global total total = x + y print(\"Soma = \", total) def soma_2(x) global total total = total + x print(total) -------------------------- soma(3,5) -> Soma = 8 soma_2(11) -> 19 No exemplo acima, a fun\u00e7\u00e3o \u201csoma_2\u201d toma como par\u00e2metro a vari\u00e1vel global \u201ctotal\u201d que tamb\u00e9m foi utilizada na fun\u00e7\u00e3o \u201csoma\u201d. Assim, a fun\u00e7\u00e3o \u201csoma_2\u201d ir\u00e1 utilizar o valor da vari\u00e1vel \u201ctotal\u201d de acordo com o que foi realizado na fun\u00e7\u00e3o \u201csoma\u201d. Um comando que tamb\u00e9m pode ser utilizado em fun\u00e7\u00f5es \u00e9 o \u201creturn\u201d. Esse comando tem o objetivo de retornar um valor ao finalizar o uso da fun\u00e7\u00e3o. Quando falamos em retornar um valor, queremos dizer que o valor retornado pela fun\u00e7\u00e3o estar\u00e1 guardado na mem\u00f3ria, mas n\u00e3o estar\u00e1 vis\u00edvel. Para torn\u00e1-lo vis\u00edvel, \u00e9 necess\u00e1rio fazer o uso de alguma fun\u00e7\u00e3o para exibi-lo. No exemplo abaixo, foi utilizada o \u201cprint\u201d para que o usu\u00e1rio possa ver o valor retornado. def soma(x,y) global total total = x + y return total ---------------- print(soma(3,5)) -> 8","title":"Fun\u00e7\u00f5es"},{"location":"1%29-Introdu%C3%A7%C3%A3o-ao-Python/#list-comprehension","text":"List Comprehension \u00e9 uma forma concisa de criar e manipular listas. Abaixo, mostramos um exemplo de cria\u00e7\u00e3o de lista das duas poss\u00edveis formas: for item in range(10): lista.append(item**2) ------------------------ lista = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] lista = [item**2 for item in range(10)] --------------------------------------- lista = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] List Comprehension com if Podemos utilizar, tamb\u00e9m, express\u00f5es condicionais para criar listas ou modificar listas existentes da seguinte forma: (Exemplo: obter os n\u00fameros pares at\u00e9 19) resultado = [numero for numero in range(20) if numero%2 == 0] ------------------------------------------------------------- resultado = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] Caso o c\u00f3digo utilizado tenha v\u00e1rios \"if\", a sintaxe ser\u00e1 feita da seguinte forma: (Exemplo: obter os m\u00faltiplos de 5 e 6 at\u00e9 99) resultado = [numero for numero in range(100) if numero%5 == 0 if numero%6 == 0] ------------------------------------------------------------------------------- resultado = [0, 30, 60, 90] List Comprehension com if...else Tamb\u00e9m \u00e9 poss\u00edvel utilizar List Comprehension com if..else utilizando a seguinte sintaxe: (Exemplo: criar lista que contenha \"1\" quando determinado n\u00famero for m\u00faltiplo de 5 e \"0\" caso contr\u00e1rio) resultado = ['1' if numero % 5 == 0 else '0' for numero in range(16)] --------------------------------------------------------------------- resultado = ['1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '1', '0', '0', '0', '0', '1'] M\u00faltiplas List Comprehension Existe a possibilidade de incluirmos List Comprehension dentro de outra List Comprehension. Essa situa\u00e7\u00e3o ocorre, normalmente, quando trabalhamos com matrizes. Abaixo, exemplificamos a transposi\u00e7\u00e3o de uma matriz utilizando List Comprehension: matriz = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] transposta = [[linha[i] for linha in matriz] for i in range(4)] --------------------------------------------------------------- transposta = [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]","title":"List Comprehension"},{"location":"2%29-Links-%C3%9Ateis/","text":"Encontram-se listadas abaxio algumas ferramentas e links que facilitam a vida do desenvolvedor PyQGIS. A API do QGIS A API do QGIS encontra-se no link https://qgis.org/api/ . No link https://qgis.org/pyqgis/master/index.html , a API encontra-se dispon\u00edvel de forma mais clara e direta. Nessas p\u00e1ginas, o desenvolvedor poder\u00e1 consultar classes e m\u00e9todos utilizados na programa\u00e7\u00e3o dos c\u00f3digos de PyQGIS. PEP 8 O PEP 8 \u00e9 um documento que lista uma s\u00e9rie de conven\u00e7\u00f5es e estilos para programa\u00e7\u00e3o em Python. Ele encontra-se dispon\u00edvel no link https://www.python.org/dev/peps/pep-0008/ Visual Studio Code O Visual Studio Code \u00e9 um editor de c\u00f3digos desenvolvido pela Microsoft que possui facilidades integradas, especialmente quando estamos trabalhando em paralelo com o Github. O VS Code encontra-se dispon\u00edvel para download no link https://code.visualstudio.com/ .","title":"2) Links \u00dateis"},{"location":"2%29-Links-%C3%9Ateis/#a-api-do-qgis","text":"A API do QGIS encontra-se no link https://qgis.org/api/ . No link https://qgis.org/pyqgis/master/index.html , a API encontra-se dispon\u00edvel de forma mais clara e direta. Nessas p\u00e1ginas, o desenvolvedor poder\u00e1 consultar classes e m\u00e9todos utilizados na programa\u00e7\u00e3o dos c\u00f3digos de PyQGIS.","title":"A API do QGIS"},{"location":"2%29-Links-%C3%9Ateis/#pep-8","text":"O PEP 8 \u00e9 um documento que lista uma s\u00e9rie de conven\u00e7\u00f5es e estilos para programa\u00e7\u00e3o em Python. Ele encontra-se dispon\u00edvel no link https://www.python.org/dev/peps/pep-0008/","title":"PEP 8"},{"location":"2%29-Links-%C3%9Ateis/#visual-studio-code","text":"O Visual Studio Code \u00e9 um editor de c\u00f3digos desenvolvido pela Microsoft que possui facilidades integradas, especialmente quando estamos trabalhando em paralelo com o Github. O VS Code encontra-se dispon\u00edvel para download no link https://code.visualstudio.com/ .","title":"Visual Studio Code"},{"location":"3%29-Console-Python/","text":"Iniciando no Console O QGIS fornece um console Python integrado para a elabora\u00e7\u00e3o de scripts. Ele pode ser iniciado pelo comando CTRL+ALT+P ou pelo menu Complementos -> Terminal Python. Criando e lendo um projeto Para criar um projeto, \u00e9 necess\u00e1rio usar o m\u00e9todo \u201cwrite()\u201d. projeto= QgsProject.instance() projeto.write('c:/Users/nome/teste.qgs') Para checar se o projeto foi realmente criado, feche e abra o QGIS e digite o c\u00f3digo para carregar o projeto. projeto= QgsProject.instance() projeto.read('c:/Users/nome/teste.qgs') 1. Adicionando camadas vetoriais \u00c9 necess\u00e1rio que se fa\u00e7a as seguintes importa\u00e7\u00f5es: import os from qgis.core import (QgsVectorLayer) Em situa\u00e7\u00f5es como essa, o programador deve especificar os indicadores da fonte de dados da camada, como, por exemplo, o nome da camada e seu diret\u00f3rio. pontos_layer = \"c:/Users/nome/pontos.shp\" vlayer = QgsVectorLayer(pontos_layer, \"pontos layer\", \"ogr\") if not vlayer.isValid(): print(\"Layer failed to load!\") else: QgsProject.instance().addMapLayer(vlayer) O jeito mais f\u00e1cil e r\u00e1pido de abrir e exibir uma camada vetorial no QGIS \u00e9 atrav\u00e9s do m\u00e9todo addVectorLayer() . path_para_pontos_layer = \"c:/Users/nome/pontos.shp\" vlayer = iface.addVectorLayer(path_para_pontos_layer, \"pontos layer\", \"ogr\") if not vlayer: print(\"Layer failed to load!\") 2. Adicionando camadas raster Para acessar arquivos raster, a biblioteca GDAL \u00e9 usada. Ele suporta uma ampla variedade de formatos de arquivo. Caso voc\u00ea tenha problemas para abrir alguns arquivos, verifique se o GDAL tem suporte para o formato espec\u00edfico (nem todos os formatos est\u00e3o dispon\u00edveis por padr\u00e3o). import os from qgis.core import (QgsVectorLayer) path_to_tif = \"C:/Users/nome/imagem.tif\" iface.addRasterLayer(path_to_tif, \"layer name you like\") if not rlayer.isValid(): print(\"Layer failed to load!\") Table of Contents \u00c9 poss\u00edvel acessar as camadas carregadas no \u00edndice para recuperar informa\u00e7\u00f5es. Pode-se utilizar o QgsProject da seguinte forma: layers = QgsProject.instance().mapLayers() print(layers) Trabalhando com camadas raster Uma camada raster consiste em uma ou mais bandas raster - conhecidas como rasters de banda \u00fanica e multi bandas. Uma banda representa uma matriz de valores. Uma imagem colorida (por exemplo, foto a\u00e9rea) \u00e9 um raster que consiste em faixas vermelhas, azuis e verdes. Abaixo, seguem comandos importantes para a manipula\u00e7\u00e3o de rasters: path_to_tif = \"C:/Users/nome/img.tif\" rlayer = QgsRasterLayer(path_to_tif, \"imagem\") Obter a resolu\u00e7\u00e3o do raster: print(rlayer.width(), rlayer.height()) -------------------------------------- 800 800 Obter a extens\u00e3o da camada em um QgsRectangle: print(rlayer.extent()) ---------------------- <QgsRectangle: 290305.20000000001164153 7471848, 291265.20000000001164153 7472808> Obter a extens\u00e3o da camada atrav\u00e9s de uma string: print(rlayer.extent().toString()) --------------------------------- 290305.2000000000116415,7471848.0000000000000000,291265.2000000000116415,7472808.0000000000000000 Obter o tipo do raster (0 = GrayOrUndefined (single band), 1 = Palette (single band), 2 = Multiband) print(rlayer.rasterType()) -------------------------- 2 Obter o n\u00famero de bandas do raster: print(rlayer.bandCount()) ------------------------- 8 Trabalhando com camadas vetoriais 1. Recuperando informa\u00e7\u00f5es sobre atributos \u00c9 poss\u00edvel recuperar informa\u00e7\u00f5es sobre os campos associados a uma camada vetorial chamando fields() de um QgsVectorLayer: vlayer = QgsVectorLayer(pontos_layer, \"pontos layer\", \"ogr\") for field in vlayer.fields(): print(field.name(), field.typeName()) 2. Iterando sobre camada vetorial A itera\u00e7\u00e3o sobre os recursos em uma camada vetorial \u00e9 uma das tarefas mais comuns. Abaixo est\u00e1 um exemplo de c\u00f3digo b\u00e1sico simples para executar esta tarefa e mostrando algumas informa\u00e7\u00f5es sobre cada recurso: pontos_layer = \"c:/users/nome_do_usuario/pontos.shp\" vlayer = iface.addVectorLayer(pontos_layer, \"pontos layer\", \"ogr\") layer = iface.activeLayer() features = layer.getFeatures() for feature in features: print(\"Feature ID: \", feature.id()) geom = feature.geometry() geomSingleType = QgsWkbTypes.isSingleType(geom.wkbType()) if geom.type() == QgsWkbTypes.PointGeometry: if geomSingleType: x = geom.asPoint() print(\"Point: \", x) else: x = geom.asMultiPoint() print(\"MultiPoint: \", x) elif geom.type() == QgsWkbTypes.LineGeometry: if geomSingleType: x = geom.asPolyline() print(\"Line: \", x, \"length: \", geom.length()) else: x = geom.asMultiPolyline() print(\"MultiLine: \", x, \"length: \", geom.length()) elif geom.type() == QgsWkbTypes.PolygonGeometry: if geomSingleType: x = geom.asPolygon() print(\"Polygon: \", x, \"Area: \", geom.area()) else: x = geom.asMultiPolygon() print(\"MultiPolygon: \", x, \"Area: \", geom.area()) else: print(\"Unknown or invalid geometry\") attrs = feature.attributes() print(attrs) break 3. Sele\u00e7\u00e3o de recursos Os recursos selecionados s\u00e3o normalmente destacados em uma cor diferente, para chamar a aten\u00e7\u00e3o do usu\u00e1rio sobre a sele\u00e7\u00e3o. \u00c0s vezes, pode ser \u00fatil selecionar recursos de forma program\u00e1tica ou alterar a cor padr\u00e3o. Para selecionar todos os recursos, o selectAll() pode ser usado: pontos_layer = \"c:/users/nome_do_usuario/pontos.shp\" vlayer = iface.addVectorLayer(pontos_layer, \"pontos layer\", \"ogr\") layer = iface.activeLayer() layer.selectAll() Para selecionar usando uma express\u00e3o, use o selectByExpression(): layer = iface.activeLayer() layer.selectByExpression('\"Class\"=\\'B52\\' and \"Heading\" > 10 and \"Heading\" <70', QgsVectorLayer.SetSelection) Para alterar a cor de sele\u00e7\u00e3o, voc\u00ea pode usar o setSelectionColor() do QgsMapCanvas mostrado no exemplo a seguir: iface.mapCanvas().setSelectionColor( QColor(\"red\") ) 4. Acessando atributos Os atributos podem ser referidos por seus nomes: print(feature['name']) Como alternativa, os atributos podem ser referenciados por \u00edndice: print(feature[1]) 5. Iterando sobre recursos selecionados Se for preciso iterar sobre um determinado subconjunto de recursos em uma camada, como aqueles dentro de uma determinada \u00e1rea, ser\u00e1 necess\u00e1rio adicionar um objeto QgsFeatureRequest \u00e0 getFeatures() chamada, como no exemplo abaixo: areaOfInterest = QgsRectangle(450290,400520, 450750,400780) request = QgsFeatureRequest().setFilterRect(areaOfInterest) for feature in layer.getFeatures(request): pass 6. Adicionar recursos Adicionar campo: from PyQt5.QtCore import QVariant layer_provider=layer.dataProvider() layer_provider.addAttributes([QgsField(\"Length\",QVariant.Double)]) layer.updateFields() print(layer.fields().names()) Deletar campo: layer_provider.deleteAttributes([1]) layer.updateFields() 7. Modificando camadas vetoriais Ao editar vetores dentro do QGIS, deve-se primeiro iniciar o modo de edi\u00e7\u00e3o para uma camada particular, ent\u00e3o fazer algumas modifica\u00e7\u00f5es e finalmente confirmar (ou reverter) as mudan\u00e7as, conforme o exemplo abaixo: from qgis.PyQt.QtCore import QVariant feat1 = feat2 = QgsFeature(layer.fields()) fid = 99 feat1.setId(fid) Adicionando duas fei\u00e7\u00f5es: layer.addFeatures([feat1,feat2]) Deletando fei\u00e7\u00e3o com ID espec\u00edfico: layer.deleteFeature(fid) Determinando nova geometria para uma fun\u00e7\u00e3o: geometry = QgsGeometry.fromWkt(\"POINT(7 45)\") layer.changeGeometry(fid, geometry) Atualizando um atributo (valor dado) a partir do \u00edndice de um campo: fieldIndex =1 value ='My new name' layer.changeAttributeValue(fid, fieldIndex, value) Adicionando um campo: layer.addAttribute(QgsField(\"mytext\", QVariant.String)) Removendo um campo: layer.deleteAttribute(fieldIndex) 8. Criando camadas vetoriais Existem v\u00e1rias maneiras de gerar um conjunto de dados de camada vetorial, dentre elas: * A classe QgsVectorFileWriter : Uma classe conveniente para gravar arquivos vetoriais em disco, usando uma chamada est\u00e1tica writeAsVectorFormat() para salvar toda a camada vetorial ou criando uma inst\u00e2ncia da classe e chamadas de emiss\u00e3o para addFeature(). * A classe QgsVectorLayer : um provedor de dados que interpreta o caminho fornecido (url) da fonte de dados para se conectar e acessar os dados. Ele pode ser usado para criar camadas tempor\u00e1rios, baseados em mem\u00f3ria ( memory) e conectar-se a conjuntos de dados OGR ( ogr), bancos de dados ( postgres, spatialite, mysql, mssql) e mais ( wfs, gpx, delimitedtext...). Manipula\u00e7\u00e3o de geometrias Pontos, linestrings e pol\u00edgonos que representam um recurso espacial s\u00e3o comumente chamados de geometrias. No QGIS, eles s\u00e3o representados com a QgsGeometry class. \u00c0s vezes, uma geometria \u00e9, na verdade, uma cole\u00e7\u00e3o de geometrias simples. Essa geometria \u00e9 chamada de multi-part geometry. Se ele cont\u00e9m apenas um tipo de geometria simples, n\u00f3s o chamamos de multi-point, multi-linestring ou multi-polygon. As coordenadas das geometrias podem estar em qualquer sistema de refer\u00eancia de coordenadas (CRS). Ao buscar recursos de uma camada, as geometrias associadas ter\u00e3o coordenadas no CRS da camada. 1. Constru\u00e7\u00e3o de geometrias O PyQGIS permite a constru\u00e7\u00e3o de diversas geometrias, por exemplo: * Coordenadas: gPnt = QgsGeometry.fromPointXY(QgsPointXY(1,1)) print(gPnt) gLine = QgsGeometry.fromPolyline([QgsPoint(1,1),QgsPoint(2,2)]) print(gLine) gPolygon = QgsGeometry.fromPolygonXY([[QgsPointXY(1,1),QgsPointXY(2,2),QgsPointXY(2,1)]]) print(gPolygon) WKT (Well Known Text): geom = QgsGeometry.fromWkt(\"POINT(3,4)\") print(geom) WKB (Well Known Binary): g = QgsGeometry() wkb = bytes.fromhex(\"010100000000000000000045400000000000001440\") g.fromWkb(wkb) 2. Acesso \u00e0 geometria \u00c9 poss\u00edvel acessar uma geometria j\u00e1 conhecida (WKB), atrav\u00e9s do m\u00e9todo wkbType(): if gPnt.wkbType() == QgsWkbTypes.Point: print(gPnt.wkbType()) if gLine.wkbType() == QgsWkbTypes.LineString: print(gLine.wkbType()) if gPolygon.wkbType() == QgsWkbTypes.Polygon: print(gPolygon.wkbType()) 3. Opera\u00e7\u00f5es e predicados de uma geometria O QGIS utiliza a biblioteca GEOS para opera\u00e7\u00f5es de geometria avan\u00e7adas, como predicados de geometria ( contains(), intersects()... ) e opera\u00e7\u00f5es de conjunto ( combine(), difference()... ). Ele tamb\u00e9m pode calcular propriedades geom\u00e9tricas, como a \u00e1rea de pol\u00edgonos ou comprimentos de pol\u00edgonos ou linhas. Abaixo, encontra-se um exemplo que combina a itera\u00e7\u00e3o dos recursos em uma determinada camada e a execu\u00e7\u00e3o de alguns c\u00e1lculos geom\u00e9tricos com base em suas geometrias. O c\u00f3digo a seguir assume que \u201clayer\u201d \u00e9 um objeto QgsVectorLayer que possui o recurso polygon: layer = QgsProject.instance().mapLayersByName('countries')[0] query = '\"name\" LIKE \\'Z%\\'' features = layer.getFeatures(QgsFeatureRequest().setFilterExpression(query)) for f in features: geom = f.geometry() name = f.attribute('NAME') print(name) print('Area: ', geom.area()) print('Perimeter: ', geom.length()) -------------------------------------- Zambia Area: 62.822790653431205 Perimeter: 50.65232014052552 Zimbabwe Area: 33.41113559136521 Perimeter: 26.608288555013935","title":"3) Console Python"},{"location":"3%29-Console-Python/#iniciando-no-console","text":"O QGIS fornece um console Python integrado para a elabora\u00e7\u00e3o de scripts. Ele pode ser iniciado pelo comando CTRL+ALT+P ou pelo menu Complementos -> Terminal Python.","title":"Iniciando no Console"},{"location":"3%29-Console-Python/#criando-e-lendo-um-projeto","text":"Para criar um projeto, \u00e9 necess\u00e1rio usar o m\u00e9todo \u201cwrite()\u201d. projeto= QgsProject.instance() projeto.write('c:/Users/nome/teste.qgs') Para checar se o projeto foi realmente criado, feche e abra o QGIS e digite o c\u00f3digo para carregar o projeto. projeto= QgsProject.instance() projeto.read('c:/Users/nome/teste.qgs') 1. Adicionando camadas vetoriais \u00c9 necess\u00e1rio que se fa\u00e7a as seguintes importa\u00e7\u00f5es: import os from qgis.core import (QgsVectorLayer) Em situa\u00e7\u00f5es como essa, o programador deve especificar os indicadores da fonte de dados da camada, como, por exemplo, o nome da camada e seu diret\u00f3rio. pontos_layer = \"c:/Users/nome/pontos.shp\" vlayer = QgsVectorLayer(pontos_layer, \"pontos layer\", \"ogr\") if not vlayer.isValid(): print(\"Layer failed to load!\") else: QgsProject.instance().addMapLayer(vlayer) O jeito mais f\u00e1cil e r\u00e1pido de abrir e exibir uma camada vetorial no QGIS \u00e9 atrav\u00e9s do m\u00e9todo addVectorLayer() . path_para_pontos_layer = \"c:/Users/nome/pontos.shp\" vlayer = iface.addVectorLayer(path_para_pontos_layer, \"pontos layer\", \"ogr\") if not vlayer: print(\"Layer failed to load!\") 2. Adicionando camadas raster Para acessar arquivos raster, a biblioteca GDAL \u00e9 usada. Ele suporta uma ampla variedade de formatos de arquivo. Caso voc\u00ea tenha problemas para abrir alguns arquivos, verifique se o GDAL tem suporte para o formato espec\u00edfico (nem todos os formatos est\u00e3o dispon\u00edveis por padr\u00e3o). import os from qgis.core import (QgsVectorLayer) path_to_tif = \"C:/Users/nome/imagem.tif\" iface.addRasterLayer(path_to_tif, \"layer name you like\") if not rlayer.isValid(): print(\"Layer failed to load!\")","title":"Criando e lendo um projeto"},{"location":"3%29-Console-Python/#table-of-contents","text":"\u00c9 poss\u00edvel acessar as camadas carregadas no \u00edndice para recuperar informa\u00e7\u00f5es. Pode-se utilizar o QgsProject da seguinte forma: layers = QgsProject.instance().mapLayers() print(layers)","title":"Table of Contents"},{"location":"3%29-Console-Python/#trabalhando-com-camadas-raster","text":"Uma camada raster consiste em uma ou mais bandas raster - conhecidas como rasters de banda \u00fanica e multi bandas. Uma banda representa uma matriz de valores. Uma imagem colorida (por exemplo, foto a\u00e9rea) \u00e9 um raster que consiste em faixas vermelhas, azuis e verdes. Abaixo, seguem comandos importantes para a manipula\u00e7\u00e3o de rasters: path_to_tif = \"C:/Users/nome/img.tif\" rlayer = QgsRasterLayer(path_to_tif, \"imagem\") Obter a resolu\u00e7\u00e3o do raster: print(rlayer.width(), rlayer.height()) -------------------------------------- 800 800 Obter a extens\u00e3o da camada em um QgsRectangle: print(rlayer.extent()) ---------------------- <QgsRectangle: 290305.20000000001164153 7471848, 291265.20000000001164153 7472808> Obter a extens\u00e3o da camada atrav\u00e9s de uma string: print(rlayer.extent().toString()) --------------------------------- 290305.2000000000116415,7471848.0000000000000000,291265.2000000000116415,7472808.0000000000000000 Obter o tipo do raster (0 = GrayOrUndefined (single band), 1 = Palette (single band), 2 = Multiband) print(rlayer.rasterType()) -------------------------- 2 Obter o n\u00famero de bandas do raster: print(rlayer.bandCount()) ------------------------- 8","title":"Trabalhando com camadas raster"},{"location":"3%29-Console-Python/#trabalhando-com-camadas-vetoriais","text":"1. Recuperando informa\u00e7\u00f5es sobre atributos \u00c9 poss\u00edvel recuperar informa\u00e7\u00f5es sobre os campos associados a uma camada vetorial chamando fields() de um QgsVectorLayer: vlayer = QgsVectorLayer(pontos_layer, \"pontos layer\", \"ogr\") for field in vlayer.fields(): print(field.name(), field.typeName()) 2. Iterando sobre camada vetorial A itera\u00e7\u00e3o sobre os recursos em uma camada vetorial \u00e9 uma das tarefas mais comuns. Abaixo est\u00e1 um exemplo de c\u00f3digo b\u00e1sico simples para executar esta tarefa e mostrando algumas informa\u00e7\u00f5es sobre cada recurso: pontos_layer = \"c:/users/nome_do_usuario/pontos.shp\" vlayer = iface.addVectorLayer(pontos_layer, \"pontos layer\", \"ogr\") layer = iface.activeLayer() features = layer.getFeatures() for feature in features: print(\"Feature ID: \", feature.id()) geom = feature.geometry() geomSingleType = QgsWkbTypes.isSingleType(geom.wkbType()) if geom.type() == QgsWkbTypes.PointGeometry: if geomSingleType: x = geom.asPoint() print(\"Point: \", x) else: x = geom.asMultiPoint() print(\"MultiPoint: \", x) elif geom.type() == QgsWkbTypes.LineGeometry: if geomSingleType: x = geom.asPolyline() print(\"Line: \", x, \"length: \", geom.length()) else: x = geom.asMultiPolyline() print(\"MultiLine: \", x, \"length: \", geom.length()) elif geom.type() == QgsWkbTypes.PolygonGeometry: if geomSingleType: x = geom.asPolygon() print(\"Polygon: \", x, \"Area: \", geom.area()) else: x = geom.asMultiPolygon() print(\"MultiPolygon: \", x, \"Area: \", geom.area()) else: print(\"Unknown or invalid geometry\") attrs = feature.attributes() print(attrs) break 3. Sele\u00e7\u00e3o de recursos Os recursos selecionados s\u00e3o normalmente destacados em uma cor diferente, para chamar a aten\u00e7\u00e3o do usu\u00e1rio sobre a sele\u00e7\u00e3o. \u00c0s vezes, pode ser \u00fatil selecionar recursos de forma program\u00e1tica ou alterar a cor padr\u00e3o. Para selecionar todos os recursos, o selectAll() pode ser usado: pontos_layer = \"c:/users/nome_do_usuario/pontos.shp\" vlayer = iface.addVectorLayer(pontos_layer, \"pontos layer\", \"ogr\") layer = iface.activeLayer() layer.selectAll() Para selecionar usando uma express\u00e3o, use o selectByExpression(): layer = iface.activeLayer() layer.selectByExpression('\"Class\"=\\'B52\\' and \"Heading\" > 10 and \"Heading\" <70', QgsVectorLayer.SetSelection) Para alterar a cor de sele\u00e7\u00e3o, voc\u00ea pode usar o setSelectionColor() do QgsMapCanvas mostrado no exemplo a seguir: iface.mapCanvas().setSelectionColor( QColor(\"red\") ) 4. Acessando atributos Os atributos podem ser referidos por seus nomes: print(feature['name']) Como alternativa, os atributos podem ser referenciados por \u00edndice: print(feature[1]) 5. Iterando sobre recursos selecionados Se for preciso iterar sobre um determinado subconjunto de recursos em uma camada, como aqueles dentro de uma determinada \u00e1rea, ser\u00e1 necess\u00e1rio adicionar um objeto QgsFeatureRequest \u00e0 getFeatures() chamada, como no exemplo abaixo: areaOfInterest = QgsRectangle(450290,400520, 450750,400780) request = QgsFeatureRequest().setFilterRect(areaOfInterest) for feature in layer.getFeatures(request): pass 6. Adicionar recursos Adicionar campo: from PyQt5.QtCore import QVariant layer_provider=layer.dataProvider() layer_provider.addAttributes([QgsField(\"Length\",QVariant.Double)]) layer.updateFields() print(layer.fields().names()) Deletar campo: layer_provider.deleteAttributes([1]) layer.updateFields() 7. Modificando camadas vetoriais Ao editar vetores dentro do QGIS, deve-se primeiro iniciar o modo de edi\u00e7\u00e3o para uma camada particular, ent\u00e3o fazer algumas modifica\u00e7\u00f5es e finalmente confirmar (ou reverter) as mudan\u00e7as, conforme o exemplo abaixo: from qgis.PyQt.QtCore import QVariant feat1 = feat2 = QgsFeature(layer.fields()) fid = 99 feat1.setId(fid) Adicionando duas fei\u00e7\u00f5es: layer.addFeatures([feat1,feat2]) Deletando fei\u00e7\u00e3o com ID espec\u00edfico: layer.deleteFeature(fid) Determinando nova geometria para uma fun\u00e7\u00e3o: geometry = QgsGeometry.fromWkt(\"POINT(7 45)\") layer.changeGeometry(fid, geometry) Atualizando um atributo (valor dado) a partir do \u00edndice de um campo: fieldIndex =1 value ='My new name' layer.changeAttributeValue(fid, fieldIndex, value) Adicionando um campo: layer.addAttribute(QgsField(\"mytext\", QVariant.String)) Removendo um campo: layer.deleteAttribute(fieldIndex) 8. Criando camadas vetoriais Existem v\u00e1rias maneiras de gerar um conjunto de dados de camada vetorial, dentre elas: * A classe QgsVectorFileWriter : Uma classe conveniente para gravar arquivos vetoriais em disco, usando uma chamada est\u00e1tica writeAsVectorFormat() para salvar toda a camada vetorial ou criando uma inst\u00e2ncia da classe e chamadas de emiss\u00e3o para addFeature(). * A classe QgsVectorLayer : um provedor de dados que interpreta o caminho fornecido (url) da fonte de dados para se conectar e acessar os dados. Ele pode ser usado para criar camadas tempor\u00e1rios, baseados em mem\u00f3ria ( memory) e conectar-se a conjuntos de dados OGR ( ogr), bancos de dados ( postgres, spatialite, mysql, mssql) e mais ( wfs, gpx, delimitedtext...).","title":"Trabalhando com camadas vetoriais"},{"location":"3%29-Console-Python/#manipulacao-de-geometrias","text":"Pontos, linestrings e pol\u00edgonos que representam um recurso espacial s\u00e3o comumente chamados de geometrias. No QGIS, eles s\u00e3o representados com a QgsGeometry class. \u00c0s vezes, uma geometria \u00e9, na verdade, uma cole\u00e7\u00e3o de geometrias simples. Essa geometria \u00e9 chamada de multi-part geometry. Se ele cont\u00e9m apenas um tipo de geometria simples, n\u00f3s o chamamos de multi-point, multi-linestring ou multi-polygon. As coordenadas das geometrias podem estar em qualquer sistema de refer\u00eancia de coordenadas (CRS). Ao buscar recursos de uma camada, as geometrias associadas ter\u00e3o coordenadas no CRS da camada. 1. Constru\u00e7\u00e3o de geometrias O PyQGIS permite a constru\u00e7\u00e3o de diversas geometrias, por exemplo: * Coordenadas: gPnt = QgsGeometry.fromPointXY(QgsPointXY(1,1)) print(gPnt) gLine = QgsGeometry.fromPolyline([QgsPoint(1,1),QgsPoint(2,2)]) print(gLine) gPolygon = QgsGeometry.fromPolygonXY([[QgsPointXY(1,1),QgsPointXY(2,2),QgsPointXY(2,1)]]) print(gPolygon) WKT (Well Known Text): geom = QgsGeometry.fromWkt(\"POINT(3,4)\") print(geom) WKB (Well Known Binary): g = QgsGeometry() wkb = bytes.fromhex(\"010100000000000000000045400000000000001440\") g.fromWkb(wkb) 2. Acesso \u00e0 geometria \u00c9 poss\u00edvel acessar uma geometria j\u00e1 conhecida (WKB), atrav\u00e9s do m\u00e9todo wkbType(): if gPnt.wkbType() == QgsWkbTypes.Point: print(gPnt.wkbType()) if gLine.wkbType() == QgsWkbTypes.LineString: print(gLine.wkbType()) if gPolygon.wkbType() == QgsWkbTypes.Polygon: print(gPolygon.wkbType()) 3. Opera\u00e7\u00f5es e predicados de uma geometria O QGIS utiliza a biblioteca GEOS para opera\u00e7\u00f5es de geometria avan\u00e7adas, como predicados de geometria ( contains(), intersects()... ) e opera\u00e7\u00f5es de conjunto ( combine(), difference()... ). Ele tamb\u00e9m pode calcular propriedades geom\u00e9tricas, como a \u00e1rea de pol\u00edgonos ou comprimentos de pol\u00edgonos ou linhas. Abaixo, encontra-se um exemplo que combina a itera\u00e7\u00e3o dos recursos em uma determinada camada e a execu\u00e7\u00e3o de alguns c\u00e1lculos geom\u00e9tricos com base em suas geometrias. O c\u00f3digo a seguir assume que \u201clayer\u201d \u00e9 um objeto QgsVectorLayer que possui o recurso polygon: layer = QgsProject.instance().mapLayersByName('countries')[0] query = '\"name\" LIKE \\'Z%\\'' features = layer.getFeatures(QgsFeatureRequest().setFilterExpression(query)) for f in features: geom = f.geometry() name = f.attribute('NAME') print(name) print('Area: ', geom.area()) print('Perimeter: ', geom.length()) -------------------------------------- Zambia Area: 62.822790653431205 Perimeter: 50.65232014052552 Zimbabwe Area: 33.41113559136521 Perimeter: 26.608288555013935","title":"Manipula\u00e7\u00e3o de geometrias"},{"location":"4%29-Processing/","text":"Instalando e abrindo o processing no QGIS O processing \u00e9 um complemento que normalmente j\u00e1 vem instalado no QGIS, por\u00e9m para us\u00e1-lo \u00e9 necess\u00e1rio ativar antes. Para ativ\u00e1-lo, v\u00e1 em: Complementos > Gerenciar e Instalar Complementos, como mostrado na figura abaixo: Na tela que se abre em seguida, clique em \u201cinstalados\u201d. D\u00ea um check ao lado da op\u00e7\u00e3o Processing. Na aba \u201cOp\u00e7\u00f5es\u201d deve ser encontrada a op\u00e7\u00e3o \u201cProcessar\u201d (ou \u201cProcessing\u201d na vers\u00e3o em Ingl\u00eas). Clique nela e em seguida em \u201cCaixa de ferramentas\u201d. No lado direito aparecer\u00e1 a caixa de ferramentas de processamento. Nela, \u00e9 poss\u00edvel encontrar v\u00e1rios processings nativos e outros pacotes de processings, como o GRASS, conforme mostrado na figura abaixo: Na Caixa de Ferramentas de processamento \u00e9 poss\u00edvel encontrar a op\u00e7\u00e3o \u201cScripts\u201d. Esta op\u00e7\u00e3o permite trabalhar com processings atrav\u00e9s de um script em Python. As op\u00e7\u00f5es s\u00e3o: \u201cCriar novo script\u201d, \u201cCriar novo script a partir do modelo\u201d, \u201cAbrir script existente\u201d e \u201cAdicionar script \u00e0 caixa de ferramentas\u201d. Estrutura de um processing Para usar um script de processamento \u00e9 necess\u00e1rio clicar em \u201cCriar novo Script a partir de modelo\", na op\u00e7\u00e3o de script dentro da caixa de ferramentas. Uma tela nova abrir\u00e1 com um modelo de script de um processing. Basicamente o script \u00e9 dividido em quatro partes: importa\u00e7\u00e3o dos objetos da API do QGIS, informa\u00e7\u00f5es do algoritmo, defini\u00e7\u00e3o dos par\u00e2metros e l\u00f3gica do algoritmo. A primeira parte do algoritmo \u00e9 a importa\u00e7\u00e3o dos objetos da API do QGIS. A segunda parte do algoritmo se refere \u00e0s informa\u00e7\u00f5es do algoritmo. N\u00e3o se pode ter espa\u00e7o entre os caracteres no nome da classe. O \u201ctr\u201d \u00e9 utilizado para tradu\u00e7\u00e3o da aplica\u00e7\u00e3o em diferentes l\u00ednguas. \u201ccreateInstance\u201d retorna uma nova inst\u00e2ncia do algoritmo. \u201cname\u201d retorna o nome do algoritmo, sendo normalmente utilizadas letras min\u00fasculas para isso. \u201cdisplayName\u201d \u00e9 o que aparece na tela do usu\u00e1rio que for usar o algoritmo. Al\u00e9m disso, tamb\u00e9m \u00e9 o nome que aparecer\u00e1 na Caixa de Ferramentas. \u201cgroup\u201d retorna o nome do grupo ao que o algoritmo pertence. Este grupo tamb\u00e9m aparece na Caixa de Ferramentas ao adicionar o script \u00e0 Caixa de Ferramentas. \u201cgroupId\u201d retorna o identificador \u00fanico do grupo ao qual o algoritmo pertence. Normalmente, s\u00e3o usadas apenas letras min\u00fasculas. \u201cshortHelpString\u201d retorna uma pequena explica\u00e7\u00e3o sobre o algoritmo, que aparece na interface do usu\u00e1rio ao usar o processing. A terceira parte do algoritmo, defini\u00e7\u00e3o dos par\u00e2metros, \u00e9 onde se define os inputs e outputs do processing. \u00c9 poss\u00edvel definir, nessa parte, valores default de input, definir a unidade de medida e o tipo de entrada e sa\u00edda. Esses par\u00e2metros devem ser declarados dentro de \u201cinitAlgorithm\u201d. A quarta, e \u00faltima parte, do processing, l\u00f3gica do algoritmo, \u00e9 onde ocorre toda a fun\u00e7\u00e3o a ser executada com os par\u00e2metros de entrada e retornando as sa\u00eddas. Esta parte normalmente se inicia acessando os par\u00e2metros de entrada nos formatos desejados e que ser\u00e3o utilizados ao longo do c\u00f3digo. Essa parte deve ficar dentro de \u201cprocessAlgorithm\u201d. Executando o processing via Python A execu\u00e7\u00e3o de processings pode se dar por meio do console Python existente no QGIS. Isso ocorre atrav\u00e9s de uma estrutura fixa e menos intuitiva, por\u00e9m de grande utilidade, uma vez que o usu\u00e1rio pode entender cada passo que ser\u00e1 executado pelo processing e identificar poss\u00edveis erros. Na linha 1 \u00e9 carregada a camada como \u201curi\u201d. A seguir, processing.run() \u00e9 o que de fato executa o processing sobre a camada de entrada. Em seguida, s\u00e3o informados os par\u00e2metros e as camadas de entrada, sequencialmente, e separados por v\u00edrgula. Veja que pode ser necess\u00e1rio mais de uma camada de entrada, nesse caso existiria mais de um \u2018INPUT\u2019 e seria necess\u00e1rio carregar mais camadas antes, por exemplo uma \u201curi_2\u201d. Na janela \u00e0 esquerda dos resultados do c\u00f3digo rodado, aparecem diversas informa\u00e7\u00f5es acerca do processing, incluindo o que ele faz, os campos a serem preenchidos e o tipo de cada elemento. Executando o processing em s\u00e9rie (GRASS e Nativo) Executar processings em s\u00e9rie, na interface do PyQGIS, nada mais \u00e9 do que executar sucessivamente v\u00e1rios processings, usando a sa\u00edda de um (output) como par\u00e2metro ou entrada (input) de outro. Para isso, \u00e9 necess\u00e1rio conhecer exatamente o nome do processing e os par\u00e2metros de entrada. No exemplo abaixo, inicialmente, carrega-se tr\u00eas camadas e define-se \u201cexpression\u201d. O primeiro processing ent\u00e3o \u00e9 executado, e o resultado \u00e9 salvo como \u201cdanube\u201d. A seguir mais uma vari\u00e1vel \u00e9 definida e o segundo processing \u00e9 executado. Perceba que na entrada dele \u00e9 passado o resultado do primeiro, \u201cdanube\u201d. Por fim, o procedimento \u00e9 repetido para o terceiro processing, e o resultado final \u00e9 exibido no QGIS pelo comando da linha 21. Definindo par\u00e2metros de entrada e sa\u00edda Os par\u00e2metros s\u00e3o definidos na fun\u00e7\u00e3o \"InitAlgorithm(self, config = none)\u201d. Sucessivamente, s\u00e3o definidos os INPUTs, par\u00e2metros auxiliares e OUTPUTs. INPUTS: \u00e9 importante definir o tipo de camada de entrada, como Point, Line ou Polygon, na \u00faltima linha. Par\u00e2metros: OUTPUTS: Ap\u00f3s definir os par\u00e2metros na parte \u201cdef InitAlgorithm()\u201d, \u00e9 importante cham\u00e1-los no c\u00f3digo principal. A estrutura para realizar essa chamada \u00e9 sempre a mesma: Executando processing dentro do processing \u00c9 poss\u00edvel, e \u00e0s vezes bastante \u00fatil, executar um processing j\u00e1 existente dentro de um processing que esteja sendo criado. Para isso, utiliza-se uma estrutura bastante similar \u00e0 execu\u00e7\u00e3o de processing na interface em Python do QGIS. Os processings s\u00e3o chamados na parte do c\u00f3digo principal, em \u201cdef processAlgorithm( )\u201d, conforme a figura acima. Ap\u00f3s isso, o resultado do processing \u00e9 salvo no par\u00e2metro de \u201cprocessing.run( )\u201d e pode ser utilizado futuramente no c\u00f3digo. Modificando camadas vetoriais via processing \u00c9 poss\u00edvel adicionar fei\u00e7\u00f5es \u00e0s camadas vetoriais utilizando-se o recurso \u201caddFeatures( )\u201d, conforme a figura abaixo: \u00c9 poss\u00edvel tamb\u00e9m excluir fei\u00e7\u00f5es com o recurso \u201cdeleteFeatures( )\u201d. \u00c9 poss\u00edvel modificar fei\u00e7\u00f5es com o recurso \u201cchangeAttributeValues( )\u201d, no caso de valores de atributos, ou \u201cchangeGeometryValues( )\u201d, no caso de geometria. Usando o feedback no processing Algumas etapas dentro do processing podem levar um longo tempo para serem executadas, fazendo com que o usu\u00e1rio n\u00e3o tenha controle sobre a etapa que est\u00e1 sendo realizada. Um recurso que pode ajudar nesse problema \u00e9 o \u201cfeedback\u201d. O feedback \u00e9 feito atrav\u00e9s do comando \u201cfeedback.setProgressText(\u2018Digite aqui o feedback...\u2019)\u201d e \u00e9 posto ao longo do c\u00f3digo antes da etapa na qual se deseja localizar. No c\u00f3digo acima, pode-se notar o feedback na linha 179, que auxilia o usu\u00e1rio a saber em qual etapa do processing encontra-se, no caso, se j\u00e1 est\u00e1 \u201cCalculando diferen\u00e7a\u201d. Portanto, \u00e9 indicado seu uso antes de cada etapa do processing. Classes QgsProcessingParameter Algumas classes muito interessantes no desenvolvimento PyQGIS s\u00e3o as do tipo QgsProcessingParameter . Abaixo, listamos aquelas bastante utilizadas em nossos c\u00f3digos: QgsProcessingParameterVectorLayer ( https://qgis.org/pyqgis/master/core/QgsProcessingParameterVectorLayer.html ) QgsProcessingParameterFeatureSink ( https://qgis.org/pyqgis/master/core/QgsProcessingParameterFeatureSink.html ) QgsProcessingParameterNumber ( https://qgis.org/pyqgis/master/core/QgsProcessingParameterNumber.html ) QgsProcessingParameterMultipleLayers ( https://qgis.org/pyqgis/master/core/QgsProcessingParameterMultipleLayers.html ) QgsProcessingParameterField ( https://qgis.org/pyqgis/master/core/QgsProcessingParameterField.html ) QgsProcessingParameterString ( https://qgis.org/pyqgis/master/core/QgsProcessingParameterString.html ) QgsProcessingParameterFeatureSource ( https://qgis.org/pyqgis/master/core/QgsProcessingParameterFeatureSource.html )","title":"4) Processing"},{"location":"4%29-Processing/#instalando-e-abrindo-o-processing-no-qgis","text":"O processing \u00e9 um complemento que normalmente j\u00e1 vem instalado no QGIS, por\u00e9m para us\u00e1-lo \u00e9 necess\u00e1rio ativar antes. Para ativ\u00e1-lo, v\u00e1 em: Complementos > Gerenciar e Instalar Complementos, como mostrado na figura abaixo: Na tela que se abre em seguida, clique em \u201cinstalados\u201d. D\u00ea um check ao lado da op\u00e7\u00e3o Processing. Na aba \u201cOp\u00e7\u00f5es\u201d deve ser encontrada a op\u00e7\u00e3o \u201cProcessar\u201d (ou \u201cProcessing\u201d na vers\u00e3o em Ingl\u00eas). Clique nela e em seguida em \u201cCaixa de ferramentas\u201d. No lado direito aparecer\u00e1 a caixa de ferramentas de processamento. Nela, \u00e9 poss\u00edvel encontrar v\u00e1rios processings nativos e outros pacotes de processings, como o GRASS, conforme mostrado na figura abaixo: Na Caixa de Ferramentas de processamento \u00e9 poss\u00edvel encontrar a op\u00e7\u00e3o \u201cScripts\u201d. Esta op\u00e7\u00e3o permite trabalhar com processings atrav\u00e9s de um script em Python. As op\u00e7\u00f5es s\u00e3o: \u201cCriar novo script\u201d, \u201cCriar novo script a partir do modelo\u201d, \u201cAbrir script existente\u201d e \u201cAdicionar script \u00e0 caixa de ferramentas\u201d.","title":"Instalando e abrindo o processing no QGIS"},{"location":"4%29-Processing/#estrutura-de-um-processing","text":"Para usar um script de processamento \u00e9 necess\u00e1rio clicar em \u201cCriar novo Script a partir de modelo\", na op\u00e7\u00e3o de script dentro da caixa de ferramentas. Uma tela nova abrir\u00e1 com um modelo de script de um processing. Basicamente o script \u00e9 dividido em quatro partes: importa\u00e7\u00e3o dos objetos da API do QGIS, informa\u00e7\u00f5es do algoritmo, defini\u00e7\u00e3o dos par\u00e2metros e l\u00f3gica do algoritmo. A primeira parte do algoritmo \u00e9 a importa\u00e7\u00e3o dos objetos da API do QGIS. A segunda parte do algoritmo se refere \u00e0s informa\u00e7\u00f5es do algoritmo. N\u00e3o se pode ter espa\u00e7o entre os caracteres no nome da classe. O \u201ctr\u201d \u00e9 utilizado para tradu\u00e7\u00e3o da aplica\u00e7\u00e3o em diferentes l\u00ednguas. \u201ccreateInstance\u201d retorna uma nova inst\u00e2ncia do algoritmo. \u201cname\u201d retorna o nome do algoritmo, sendo normalmente utilizadas letras min\u00fasculas para isso. \u201cdisplayName\u201d \u00e9 o que aparece na tela do usu\u00e1rio que for usar o algoritmo. Al\u00e9m disso, tamb\u00e9m \u00e9 o nome que aparecer\u00e1 na Caixa de Ferramentas. \u201cgroup\u201d retorna o nome do grupo ao que o algoritmo pertence. Este grupo tamb\u00e9m aparece na Caixa de Ferramentas ao adicionar o script \u00e0 Caixa de Ferramentas. \u201cgroupId\u201d retorna o identificador \u00fanico do grupo ao qual o algoritmo pertence. Normalmente, s\u00e3o usadas apenas letras min\u00fasculas. \u201cshortHelpString\u201d retorna uma pequena explica\u00e7\u00e3o sobre o algoritmo, que aparece na interface do usu\u00e1rio ao usar o processing. A terceira parte do algoritmo, defini\u00e7\u00e3o dos par\u00e2metros, \u00e9 onde se define os inputs e outputs do processing. \u00c9 poss\u00edvel definir, nessa parte, valores default de input, definir a unidade de medida e o tipo de entrada e sa\u00edda. Esses par\u00e2metros devem ser declarados dentro de \u201cinitAlgorithm\u201d. A quarta, e \u00faltima parte, do processing, l\u00f3gica do algoritmo, \u00e9 onde ocorre toda a fun\u00e7\u00e3o a ser executada com os par\u00e2metros de entrada e retornando as sa\u00eddas. Esta parte normalmente se inicia acessando os par\u00e2metros de entrada nos formatos desejados e que ser\u00e3o utilizados ao longo do c\u00f3digo. Essa parte deve ficar dentro de \u201cprocessAlgorithm\u201d.","title":"Estrutura de um processing"},{"location":"4%29-Processing/#executando-o-processing-via-python","text":"A execu\u00e7\u00e3o de processings pode se dar por meio do console Python existente no QGIS. Isso ocorre atrav\u00e9s de uma estrutura fixa e menos intuitiva, por\u00e9m de grande utilidade, uma vez que o usu\u00e1rio pode entender cada passo que ser\u00e1 executado pelo processing e identificar poss\u00edveis erros. Na linha 1 \u00e9 carregada a camada como \u201curi\u201d. A seguir, processing.run() \u00e9 o que de fato executa o processing sobre a camada de entrada. Em seguida, s\u00e3o informados os par\u00e2metros e as camadas de entrada, sequencialmente, e separados por v\u00edrgula. Veja que pode ser necess\u00e1rio mais de uma camada de entrada, nesse caso existiria mais de um \u2018INPUT\u2019 e seria necess\u00e1rio carregar mais camadas antes, por exemplo uma \u201curi_2\u201d. Na janela \u00e0 esquerda dos resultados do c\u00f3digo rodado, aparecem diversas informa\u00e7\u00f5es acerca do processing, incluindo o que ele faz, os campos a serem preenchidos e o tipo de cada elemento.","title":"Executando o processing via Python"},{"location":"4%29-Processing/#executando-o-processing-em-serie-grass-e-nativo","text":"Executar processings em s\u00e9rie, na interface do PyQGIS, nada mais \u00e9 do que executar sucessivamente v\u00e1rios processings, usando a sa\u00edda de um (output) como par\u00e2metro ou entrada (input) de outro. Para isso, \u00e9 necess\u00e1rio conhecer exatamente o nome do processing e os par\u00e2metros de entrada. No exemplo abaixo, inicialmente, carrega-se tr\u00eas camadas e define-se \u201cexpression\u201d. O primeiro processing ent\u00e3o \u00e9 executado, e o resultado \u00e9 salvo como \u201cdanube\u201d. A seguir mais uma vari\u00e1vel \u00e9 definida e o segundo processing \u00e9 executado. Perceba que na entrada dele \u00e9 passado o resultado do primeiro, \u201cdanube\u201d. Por fim, o procedimento \u00e9 repetido para o terceiro processing, e o resultado final \u00e9 exibido no QGIS pelo comando da linha 21.","title":"Executando o processing em s\u00e9rie (GRASS e Nativo)"},{"location":"4%29-Processing/#definindo-parametros-de-entrada-e-saida","text":"Os par\u00e2metros s\u00e3o definidos na fun\u00e7\u00e3o \"InitAlgorithm(self, config = none)\u201d. Sucessivamente, s\u00e3o definidos os INPUTs, par\u00e2metros auxiliares e OUTPUTs. INPUTS: \u00e9 importante definir o tipo de camada de entrada, como Point, Line ou Polygon, na \u00faltima linha. Par\u00e2metros: OUTPUTS: Ap\u00f3s definir os par\u00e2metros na parte \u201cdef InitAlgorithm()\u201d, \u00e9 importante cham\u00e1-los no c\u00f3digo principal. A estrutura para realizar essa chamada \u00e9 sempre a mesma:","title":"Definindo par\u00e2metros de entrada e sa\u00edda"},{"location":"4%29-Processing/#executando-processing-dentro-do-processing","text":"\u00c9 poss\u00edvel, e \u00e0s vezes bastante \u00fatil, executar um processing j\u00e1 existente dentro de um processing que esteja sendo criado. Para isso, utiliza-se uma estrutura bastante similar \u00e0 execu\u00e7\u00e3o de processing na interface em Python do QGIS. Os processings s\u00e3o chamados na parte do c\u00f3digo principal, em \u201cdef processAlgorithm( )\u201d, conforme a figura acima. Ap\u00f3s isso, o resultado do processing \u00e9 salvo no par\u00e2metro de \u201cprocessing.run( )\u201d e pode ser utilizado futuramente no c\u00f3digo.","title":"Executando processing dentro do processing"},{"location":"4%29-Processing/#modificando-camadas-vetoriais-via-processing","text":"\u00c9 poss\u00edvel adicionar fei\u00e7\u00f5es \u00e0s camadas vetoriais utilizando-se o recurso \u201caddFeatures( )\u201d, conforme a figura abaixo: \u00c9 poss\u00edvel tamb\u00e9m excluir fei\u00e7\u00f5es com o recurso \u201cdeleteFeatures( )\u201d. \u00c9 poss\u00edvel modificar fei\u00e7\u00f5es com o recurso \u201cchangeAttributeValues( )\u201d, no caso de valores de atributos, ou \u201cchangeGeometryValues( )\u201d, no caso de geometria.","title":"Modificando camadas vetoriais via processing"},{"location":"4%29-Processing/#usando-o-feedback-no-processing","text":"Algumas etapas dentro do processing podem levar um longo tempo para serem executadas, fazendo com que o usu\u00e1rio n\u00e3o tenha controle sobre a etapa que est\u00e1 sendo realizada. Um recurso que pode ajudar nesse problema \u00e9 o \u201cfeedback\u201d. O feedback \u00e9 feito atrav\u00e9s do comando \u201cfeedback.setProgressText(\u2018Digite aqui o feedback...\u2019)\u201d e \u00e9 posto ao longo do c\u00f3digo antes da etapa na qual se deseja localizar. No c\u00f3digo acima, pode-se notar o feedback na linha 179, que auxilia o usu\u00e1rio a saber em qual etapa do processing encontra-se, no caso, se j\u00e1 est\u00e1 \u201cCalculando diferen\u00e7a\u201d. Portanto, \u00e9 indicado seu uso antes de cada etapa do processing.","title":"Usando o feedback no processing"},{"location":"4%29-Processing/#classes-qgsprocessingparameter","text":"Algumas classes muito interessantes no desenvolvimento PyQGIS s\u00e3o as do tipo QgsProcessingParameter . Abaixo, listamos aquelas bastante utilizadas em nossos c\u00f3digos: QgsProcessingParameterVectorLayer ( https://qgis.org/pyqgis/master/core/QgsProcessingParameterVectorLayer.html ) QgsProcessingParameterFeatureSink ( https://qgis.org/pyqgis/master/core/QgsProcessingParameterFeatureSink.html ) QgsProcessingParameterNumber ( https://qgis.org/pyqgis/master/core/QgsProcessingParameterNumber.html ) QgsProcessingParameterMultipleLayers ( https://qgis.org/pyqgis/master/core/QgsProcessingParameterMultipleLayers.html ) QgsProcessingParameterField ( https://qgis.org/pyqgis/master/core/QgsProcessingParameterField.html ) QgsProcessingParameterString ( https://qgis.org/pyqgis/master/core/QgsProcessingParameterString.html ) QgsProcessingParameterFeatureSource ( https://qgis.org/pyqgis/master/core/QgsProcessingParameterFeatureSource.html )","title":"Classes QgsProcessingParameter"},{"location":"5%29-Plugin/","text":"Plugins s\u00e3o programas, ou extens\u00f5es, com o objetivo de adicionar recursos e funcionalidades extras a algum programa principal. Os plugins s\u00e3o ferramentas essenciais em diversos programas, pois, como no caso do QGIS, possibilitam desenvolvedores de incrementarem as ferramentas dispon\u00edveis conforme as necessidades encontradas, n\u00e3o requisitando do criador do programa base a inser\u00e7\u00e3o daquela funcionalidade. Com isso, \u00e9 poss\u00edvel baixar extens\u00f5es, criadas pelos desenvolvedores do QGIS, ou independentes, que atuem mais especificamente no tema demandado. Criando um plugin no QGIS S\u00e3o necess\u00e1rios alguns passos para a cria\u00e7\u00e3o de um plugin no QGIS. Abaixo, listamos eles: * Instalar o Plugin Builder 3 no QGIS. Na aba \u201cComplementos\u201d, clicar em \u201cGerenciar e Instalar Complementos...\u201d. Pesquisar \u201cPlugin Builder\u201d. Clicar em \u201cInstalar complemento\u201d. Abrir a aba \u201cComplementos\u201d, ir em \u201cPlugin Builder\u201d e abrir o \u201cPlugin Builder\u201d. Preencher os seguintes campos: Class Name: Nome para criar a classe Python do plugin. Module Name: Nome para criar o m\u00f3dulo (arquivo) do plugin. Plugin Name: T\u00edtulo para o Plugin (no plugin manager e instalador). Description: Descri\u00e7\u00e3o breve da fun\u00e7\u00e3o do plugin. Version Number: N\u00famero da vers\u00e3o do plugin, sugest\u00e3o 0.1. Minimum QGIS Version: Vers\u00e3o do QGIS necess\u00e1ria para o plugin funcionar. Author: Autor do plugin. Email Address: Email para contato dos usu\u00e1rios do plugin. Preencher a descri\u00e7\u00e3o detalhada do plugin. Escolher o tipo de plugin a ser criado e o texto para ser exibido no menu. Escolher o menu em que aparecer\u00e1 o plugin. Escolher os componentes adicionais do plugin: Internationalization: Adicionar textos transcritos ao plugin. Help: Cria um arquivo de ajuda. Unit tests: Cria conjunto de testes para o plugin. Helper scripts: Adiciona um script de ajuda para o plugin. Makefile: Adiciona um Makefile para o plugin. Preencher tamb\u00e9m: Bug Tracker: Url para o bug tracker do plugin. Repository: algum reposit\u00f3rio como GitHub Home page (opcional): p\u00e1gina do plugin Tags (opcional). QT Designer A utiliza\u00e7\u00e3o do Qt Designer \u00e9 muito indicada por alguns motivos. Primeiramente, ele \u00e9 um programa simples e com muitas funcionalidades para a cria\u00e7\u00e3o de UIs (User Interfaces), permitindo ao desenvolvedor modelar uma interface da forma que quiser de maneira visual e pr\u00e1tica. Al\u00e9m disso, outra grande vantagem do programa \u00e9 j\u00e1 vir instalado com o QGIS, havendo uma boa integra\u00e7\u00e3o entre os programas. Assim, qualquer m\u00e1quina com o QGIS instalado deve ter o Qt Designer a parte, como na figura abaixo. Ao abrir o programa, a seguinte janela aparecer\u00e1: Selecione \u201cCreate\u201d, criando, assim, uma caixa de di\u00e1logo com bot\u00f5es, fazendo com que seja poss\u00edvel criar uma interface do zero. Assim, chega-se ao programa em si, que pode ser dividido em partes, conforme ser\u00e1 explicado abaixo. 1. Caixa de Ferramentas (Widget Box) Os elementos da interface podem ter diversas funcionalidades, sendo classificados como widgets e divididos em tipos, tendo cada um a sua especifica\u00e7\u00e3o. Ao arrastar um desses widgets para a sua interface, ele ser\u00e1 adicionado e pode ser customizado de v\u00e1rias formas. Existem mais widgets ainda do que mostrados na imagem abaixo, alguns com funcionalidades espec\u00edficas para o QGIS, inclusive. 2. Configura\u00e7\u00e3o de layout: Nesta parte, as v\u00e1rias formas de configura\u00e7\u00e3o de layout s\u00e3o disponibilizadas e podem ser inseridas para a estrutura\u00e7\u00e3o dos elementos na interface. Podem ser vistos os formatos verticais, horizontais, agrupados, entre outros. Apesar de n\u00e3o parecer muito essencial num primeiro momento, a formata\u00e7\u00e3o de layout \u00e9 muito importante para a esquematiza\u00e7\u00e3o da interface, ordenamento dos itens e facilita tamb\u00e9m a mudan\u00e7a de escala e espa\u00e7amento da interface. 3. Inspe\u00e7\u00e3o de objeto Nesta aba, os elementos gr\u00e1ficos ser\u00e3o mostrados de forma hier\u00e1rquica, assim sendo importante alter\u00e1-la se for necess\u00e1ria uma varia\u00e7\u00e3o em caso de sobreposi\u00e7\u00e3o. Aqui tamb\u00e9m \u00e9 mostrado a estrutura\u00e7\u00e3o de layouts que podem estar presentes e quais elementos est\u00e3o inseridos nele, como no exemplo ao lado com um formato de grupos e 3 Check Boxs existentes. 4. Editor de propriedades Por fim, a aba de edi\u00e7\u00e3o das propriedades de um elemento. Essa \u00e9 uma das abas mais importantes, pois nela \u00e9 poss\u00edvel editar praticamente qualquer caracter\u00edstica do elemento inserido. Entre essas altera\u00e7\u00f5es, pode-se mexer na geometria, nome, fonte e mais funcionalidades. Essas caracter\u00edsticas tamb\u00e9m podem ser alteradas por c\u00f3digo, ao se criar o plugin em si. Esse editor tamb\u00e9m mostra o nome do elemento, que deve ser utilizado se necess\u00e1rio via c\u00f3digo.","title":"5) Plugin"},{"location":"5%29-Plugin/#criando-um-plugin-no-qgis","text":"S\u00e3o necess\u00e1rios alguns passos para a cria\u00e7\u00e3o de um plugin no QGIS. Abaixo, listamos eles: * Instalar o Plugin Builder 3 no QGIS. Na aba \u201cComplementos\u201d, clicar em \u201cGerenciar e Instalar Complementos...\u201d. Pesquisar \u201cPlugin Builder\u201d. Clicar em \u201cInstalar complemento\u201d. Abrir a aba \u201cComplementos\u201d, ir em \u201cPlugin Builder\u201d e abrir o \u201cPlugin Builder\u201d. Preencher os seguintes campos: Class Name: Nome para criar a classe Python do plugin. Module Name: Nome para criar o m\u00f3dulo (arquivo) do plugin. Plugin Name: T\u00edtulo para o Plugin (no plugin manager e instalador). Description: Descri\u00e7\u00e3o breve da fun\u00e7\u00e3o do plugin. Version Number: N\u00famero da vers\u00e3o do plugin, sugest\u00e3o 0.1. Minimum QGIS Version: Vers\u00e3o do QGIS necess\u00e1ria para o plugin funcionar. Author: Autor do plugin. Email Address: Email para contato dos usu\u00e1rios do plugin. Preencher a descri\u00e7\u00e3o detalhada do plugin. Escolher o tipo de plugin a ser criado e o texto para ser exibido no menu. Escolher o menu em que aparecer\u00e1 o plugin. Escolher os componentes adicionais do plugin: Internationalization: Adicionar textos transcritos ao plugin. Help: Cria um arquivo de ajuda. Unit tests: Cria conjunto de testes para o plugin. Helper scripts: Adiciona um script de ajuda para o plugin. Makefile: Adiciona um Makefile para o plugin. Preencher tamb\u00e9m: Bug Tracker: Url para o bug tracker do plugin. Repository: algum reposit\u00f3rio como GitHub Home page (opcional): p\u00e1gina do plugin Tags (opcional).","title":"Criando um plugin no QGIS"},{"location":"5%29-Plugin/#qt-designer","text":"A utiliza\u00e7\u00e3o do Qt Designer \u00e9 muito indicada por alguns motivos. Primeiramente, ele \u00e9 um programa simples e com muitas funcionalidades para a cria\u00e7\u00e3o de UIs (User Interfaces), permitindo ao desenvolvedor modelar uma interface da forma que quiser de maneira visual e pr\u00e1tica. Al\u00e9m disso, outra grande vantagem do programa \u00e9 j\u00e1 vir instalado com o QGIS, havendo uma boa integra\u00e7\u00e3o entre os programas. Assim, qualquer m\u00e1quina com o QGIS instalado deve ter o Qt Designer a parte, como na figura abaixo. Ao abrir o programa, a seguinte janela aparecer\u00e1: Selecione \u201cCreate\u201d, criando, assim, uma caixa de di\u00e1logo com bot\u00f5es, fazendo com que seja poss\u00edvel criar uma interface do zero. Assim, chega-se ao programa em si, que pode ser dividido em partes, conforme ser\u00e1 explicado abaixo. 1. Caixa de Ferramentas (Widget Box) Os elementos da interface podem ter diversas funcionalidades, sendo classificados como widgets e divididos em tipos, tendo cada um a sua especifica\u00e7\u00e3o. Ao arrastar um desses widgets para a sua interface, ele ser\u00e1 adicionado e pode ser customizado de v\u00e1rias formas. Existem mais widgets ainda do que mostrados na imagem abaixo, alguns com funcionalidades espec\u00edficas para o QGIS, inclusive. 2. Configura\u00e7\u00e3o de layout: Nesta parte, as v\u00e1rias formas de configura\u00e7\u00e3o de layout s\u00e3o disponibilizadas e podem ser inseridas para a estrutura\u00e7\u00e3o dos elementos na interface. Podem ser vistos os formatos verticais, horizontais, agrupados, entre outros. Apesar de n\u00e3o parecer muito essencial num primeiro momento, a formata\u00e7\u00e3o de layout \u00e9 muito importante para a esquematiza\u00e7\u00e3o da interface, ordenamento dos itens e facilita tamb\u00e9m a mudan\u00e7a de escala e espa\u00e7amento da interface. 3. Inspe\u00e7\u00e3o de objeto Nesta aba, os elementos gr\u00e1ficos ser\u00e3o mostrados de forma hier\u00e1rquica, assim sendo importante alter\u00e1-la se for necess\u00e1ria uma varia\u00e7\u00e3o em caso de sobreposi\u00e7\u00e3o. Aqui tamb\u00e9m \u00e9 mostrado a estrutura\u00e7\u00e3o de layouts que podem estar presentes e quais elementos est\u00e3o inseridos nele, como no exemplo ao lado com um formato de grupos e 3 Check Boxs existentes. 4. Editor de propriedades Por fim, a aba de edi\u00e7\u00e3o das propriedades de um elemento. Essa \u00e9 uma das abas mais importantes, pois nela \u00e9 poss\u00edvel editar praticamente qualquer caracter\u00edstica do elemento inserido. Entre essas altera\u00e7\u00f5es, pode-se mexer na geometria, nome, fonte e mais funcionalidades. Essas caracter\u00edsticas tamb\u00e9m podem ser alteradas por c\u00f3digo, ao se criar o plugin em si. Esse editor tamb\u00e9m mostra o nome do elemento, que deve ser utilizado se necess\u00e1rio via c\u00f3digo.","title":"QT Designer"},{"location":"6%29-Colaboradores/","text":"FELIPE DE CARVALHO DINIZ JOS\u00c9 ELITON ALBUQUERQUE FILHO HENRIQUE SILVA MELO PEDRO MARTINS DE SOUZA ANTONIO SOARES FEITOSA JUNIOR GABRIEL HENRIQUE CABEZAS ASSIS HENRIQUE CARNEIRO CAPUTO EDGARD GUITTON RENAUD BAPTISTA DE OLIVEIRA LUCAS DUARTE FERNANDES FELIPE YAMAMOTO FERREIRA AGUIAR DANIEL DAHER MOURA LINCOLN ESTEVES DOS ANJOS SILVA DIENE XIE ADRIANO LUCAS MACHADO CORR\u00caA SCHULZ E SILVA JO\u00c3O VICTOR DE OLIVEIRA QUEIROZ ANTONIO SANTANA DE OLIVEIRA","title":"6) Colaboradores"}]}